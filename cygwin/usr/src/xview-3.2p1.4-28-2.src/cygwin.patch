# patch to fix compilation on cygwin
#
# made by a diff between:
# - the xview-3.2p1.4-19c source package from physionet.org (which can be compiled for cygwin)
# - the source tree produced by 3.2p1.4-19 debian package (on which it was presumably based)
# then fixed up
#
--- origsrc/xview-3.2p1.4/Build-LinuxXView.bash	2013-02-23 14:43:36.171875000 +0000
+++ src/xview-3.2p1.4/Build-LinuxXView.bash	2013-02-23 14:45:18.390625000 +0000
@@ -1,4 +1,7 @@
-# This script sets up the necessary environment to build XView for Linux.
+# This script sets up the necessary environment to build XView.  It was
+# written (by Martin Buck?) for Linux, but it also works under MS-Windows
+# (see README.WINDOWS) and is a good starting point for a build on a new
+# platform.
 # It should be sourced by bash or run with one of the arguments shown below.
 # If you want to use a installation directory prefix different from /, set
 # $DESTDIR accordingly. Setting $OPENWINHOME to values != /usr/openwin
--- origsrc/xview-3.2p1.4/README.FIRST	1970-01-01 01:00:00.000000000 +0100
+++ src/xview-3.2p1.4/README.FIRST	2013-02-23 14:44:37.593750000 +0000
@@ -0,0 +1,43 @@
+file: README.FIRST	G. Moody	31 January 2005
+			Last revised:	  8 April 2005
+
+This directory contains sources for the XView and olgx libraries, an X Window
+System graphical user interface toolkit that implements the OPEN LOOK GUI
+specification.  Sources for several standard XView applications are also
+included here.  The most recent version of this package is always available
+from PhysioNet's XView repository at
+	http://physionet.org/physiotools/xview/ 
+The PhysioNet XView repository also provides precompiled XView binaries for
+GNU/Linux, Mac OS X, and MS-Windows, and pointers to XView packages for other
+platforms.
+
+An outstanding resource for information about XView is a set of three books
+available freely from O'Reilly's Open Books Project:
+	http://www.oreilly.com/openbook/openlook/
+
+This directory contains sources for the XView toolkit, version 3.2p1.4-19c,
+based on the Debian GNU/Linux XView version 3.2p1.4-19, with additional patches
+that allow it to be compiled and used successfully with:
+
+  * modern GNU/Linux distributions that lack support for (deprecated) BSD ptys,
+    but that do have UNIX98 (SYSV) pty support (see README.LINUX)
+
+  * MS-Windows, when compiled using Cygwin gcc, and while running the
+    Cygwin/x.org X server (see README.WINDOWS)
+
+This version should also work on any of the previously supported platforms; the
+modifications with respect to the Debian 3.2p1.4-19 version are minimal.  See
+the other README files in this directory for information about building and
+installing XView on various platforms; if your platform is not among these, try
+following the build instructions for GNU/Linux.
+
+This version was prepared by Isaac Henry (ihenry@physionet.org) and George
+Moody (george@mit.edu).  It is based on Martin Buck's Debian version, which is
+based on Oleg Kibirev's release for Linux/ELF, which is based on earlier work
+for Linux/COFF by Kenneth Osterberg, Wolfram Gloger, E. Zimmermann, Rainer
+Wiesner, Sven Rudolph, Sebastiano Suraci, and Martin Buck, with additional
+contributions from Frodo Looijaard and Roman Hodek; this in turn was based on
+Joern Lubkoll's xview-3.2p1 for X11R6 on SunOS, which was based on Sun's XView
+3.2 release of 1/7/92 for X11R5 on SunOS.  See the directory named "old" for
+the history of this software; the contents of that directory were formerly
+here, but have been moved aside to reduce confusion about the build process.
--- origsrc/xview-3.2p1.4/README.LINUX	1970-01-01 01:00:00.000000000 +0100
+++ src/xview-3.2p1.4/README.LINUX	2013-02-23 14:44:37.593750000 +0000
@@ -0,0 +1,51 @@
+file: README.LINUX		G. Moody (george@mit.edu)	1 February 2005
+					Last revised:		 8 April 2005
+
+Building, installing, and using XView under GNU/Linux
+
+XView packages for GNU/Linux are available from several sources, notably from
+Debian (on which this are based).  At this time, however, the XView packages
+available from Debian and other sources require support for BSD ptys, which is
+no longer standard in distributions based on the 2.6 kernel.  This version of
+XView is compatible with the newer UNIX98 (SYSV) ptys supported in 2.6-based
+distributions such as Fedora Core 2 and later;  it will also work with older
+2.x-based kernels that typically include support for both BSD and UNIX98 ptys.
+
+1. If you have not already done so, download and unpack the tarball of
+   XView sources:
+	tar xfvz xview-3.2p1.4-19c.tar.gz
+
+2. Compile and install the XView libraries and clients:
+	cd xview-3.2p1.4-18c
+	bash Build-XView.bash libs instlibs clients instclients
+   
+   This procedure will take a long time and will generate thousands of lines
+   of progress and warning messages.  When it is complete, the libraries,
+   *.h files, and xview clients will all have been installed in subdirectories
+   of /usr/openwin.  If you wish to copy the binaries to another system, it is
+   sufficient to copy the contents of /usr/openwin.
+
+3. Add /usr/openwin/lib to /etc/ld.so.conf and run /sbin/ldconfig (requires
+   root permissions) before attempting to compile or run any other XView
+   applications.  To simplify running the standard XView clients, it may be
+   helpful to add /usr/openwin/bin to your PATH.
+
+4. Run this command:
+	xdpyinfo | grep backing
+
+   If the output is similar to:
+	  options:    backing-store NO, save-unders NO
+   then you will need to enable backing store by inserting the line
+	  Option      "backingstore"
+   in the Device section of your X server configuration file (normally one of
+   /etc/X11/xorg.conf, /etc/X11/XF86Config, or /etc/X11/XF86Config-4).
+   (Alternatively, you can run your X server with the option +bs to obtain the
+   same result without editing your configuration file.)  Restart your X
+   server, then run the xdpyinfo command again to verify that backing store is
+   now enabled.
+
+   Recent Linux distributions are configured so that the X server runs with
+   backing store disabled, which causes XView applications to open with blank
+   (solid white) windows.  Usually resizing or refreshing such windows causes
+   their contents to appear, but enabling backing store avoids this problem
+   entirely.
--- origsrc/xview-3.2p1.4/README.LinuxELF	1997-06-15 20:50:38.000000000 +0100
+++ src/xview-3.2p1.4/README.LinuxELF	1970-01-01 01:00:00.000000000 +0100
@@ -1,120 +0,0 @@
-This README describes Linux-patchlevel 4 of XView3.2p1-X11R6, Sun's
-OpenLook[tm] compliant graphical user-interface toolkit for Linux/ELF and
-the X Window System.
-
-If you have never heard about XView before, here's a short excerpt of Sun's
-README:
-XView (X Window-System-based Visual/Integrated Environment for Workstations)
-is a user-interface toolkit to support interactive, graphics-based
-applications running under the X Window System.  XView provides a set of
-pre-built, user-interface objects such as canvases, scrollbars, menus, and
-control panels.  The appearance and functionality of these objects follow
-the OPEN LOOK Graphical User Interface (GUI) specification.  XView features
-an object-oriented style Application Programmer's Interface (API) that is
-straightforward and easy to learn.
-
-
-This release is based on Oleg Kibirev's release of XView for Linux/ELF. It
-contains patches from Oleg Kibirev <oleg@gd.cs.CSUFresno.EDU> (his patches
-are based mostly on Kenneth Osterberg's <lmfken@lmf.ericsson.se> patches),
-Wolfram Gloger <Gloger@lrz.uni-muenchen.de>, E. Zimmermann <edz@bsn.com>,
-Rainer Wiesner <RainerRW@aol.com>, Sven Rudolph <sr1@os.inf.tu-dresden.de>,
-Sebastiano Suraci <suraci@uniud.it> and myself. If you have other patches
-for XView-bugs, please send them to me.
-
-Although I fixed some bugs in cmdtool, there are many more left. The code
-for cmdtool is a complete mess and I don't want to waste any more time
-fixing it. As such, bug-reports for cmdtool will be ignored unless you also
-include a patch. If you want to do yourself a favour, use xterm. :-)
-
-Changes from earlier versions:
-
-Patchlevel 4:
-o Fixed bug in Notifier that caused cmdtool to dump core when running
-  fullscreen-programs like vi or emacs.
-o ttysw/termsw (cmdtool) now correctly handles NOECHO mode
-o NumLock no longer causes X protocol error
-o Numeric keypad should work
-o Caret now is (re)drawn correctly in PANEL_TEXT_ITEMs
-o Fixed bug that caused menu items to become invisible when XView ran out
-  of colors
-o Fixed BadMatch error when using colored icons
-o Fixed bug that caused random SIGSEGVs when drawing lines with pixwin
-o Fixed olgx bug that caused height miscalculation for PANEL_LABEL_IMAGEs
-o olvwm no longer dumps core when no menu-file is found
-o olvwm now displays accelerators in its menus
-o props no longer complains about missing localization files
-o $OPENWINHOME no longer required -- everything now uses /usr/openwin by
-  default, if $OPENWINHOME is unset
-o All installation-rules in the Imake-config-files now use the $DESTDIR-
-  prefix for the installation-directories
-o Using Ncurses, libtermcap is no longer required
-o Removed /usr/openwin/bin/sunview (executables now in /usr/openwin/bin,
-  scripts in /usr/openwin/lib/xview)
-o Fixed some compilation problems
-
-Patchlevel 3 adds the TrueColor-patches for ol(v)wm, fixes the
-buffer-overrun problem with cmdtool (that caused cmdtool's output to be
-written to the terminal cmdtool was started from), fixes a GC-problem when
-using 2D buttons (that showed up when attaching a menu to a canvas using all
-256 colors on a 8 bpp display, for example), fixes a resource problem with
-olvwm, changes the default location for the text-extras-menu from /usr/lib
-to /usr/openwin/lib and contains some other minor enhancements. Also, olvwm
-now is included in the source-package and the diffs only contain the patches
-for the additional clients (instead of the whole clients-sourcecode).
-
-Patchlevel 2 finally fixes the nasty endianess-bug with icons and also
-contains some other minor enhancements. Also, I removed the seperate
-clients-package and added the sources to my diffs instead. I also merged
-Kenneth's diffs to the example-programs that were missing in Oleg's release.
-
-Patchlevel 1 fixes some bugs that existed in all XView-versions since X11R6
-(some might even be older). They could cause coredumps or other
-miscellaneous failures like ignoring the resoure-database and displaying
-PANEL_LISTS with wrong colors. It also includes some malloc-related bugfixes
-that should allow you to debug XView-apps with Electric Fence.
-
-
-You can find the following files on sunsite.unc.edu in
-/pub/Linux/libs/X/xview:
-
-xview-3.2p1.4.bin.tar.gz:
-  This is the binary release that contains everything that's required to
-  use the XView-library. It also contains binaries of the basic XView
-  clients (olwm, clock, cmdtool and shelltool) and additional clients (props,
-  textedit and olvwm). The binaries were compiled with libc-5.2.16,
-  libX11.so.6.0 and libncurses.so.3.0, but should work with later versions as
-  well.
-xview-3.2p1.4.src.tar.gz:
-  This is the sourcecode for the XView-library with my patches (see below)
-  applied and the additional clients included.
-xview-3.2p1.4.diff.gz:
-  These are my patches relative to the XView3.2p1-X11R6-release as found on
-  ftp.x.org. To apply the patches, you first have to install the additional
-  clients in the 'clients'-directory
-xview-3.2p1.4.README:
-  The file you're reading at the moment
-xview-3.2p1.4.lsm:
-  ...and the LSM-entry
-
-To install the binary version, do the following:
-If you have an old XView-release installed, you might want to move your old
-/usr/openwin tree to a save place first. Then cd to / and do a
-"tar xvpzf /some/path/xview-3.2p1.4.bin.tar.gz" (as root). After
-running "ldconfig /usr/openwin/lib" (and possibly adding /usr/openwin/lib to
-/etc/ld.so.config first), you should be able to use the new libraries.
-
-BTW, I chose version 3.2.4 for the shared libraries. This means that they're
-compatible with the old versions---you don't have to recompile your apps to
-use the new version (if they were liked against the shared libs, that is).
-
-To compile XView yourself, please have a look at the bash-script
-"Build-LinuxXView.bash" in my source-distribution. If your setup is not too
-different from mine, this should do most of the required steps for you.
-
-HINT TO DISTRIBUTION-MAINTAINERS:
-*PLEASE* replace your current XView-packages with this new one. You can save
-your users and all programmers of XView-apps a lot of trouble.
-
-
-Martin Buck <martin.buck@bigfoot.com>
--- origsrc/xview-3.2p1.4/README.WINDOWS	1970-01-01 01:00:00.000000000 +0100
+++ src/xview-3.2p1.4/README.WINDOWS	2013-02-23 14:44:37.609375000 +0000
@@ -0,0 +1,122 @@
+file: README.WINDOWS		G. Moody (george@mit.edu)	1 February 2005
+					Last revised:		 8 April 2005
+
+Building, installing, and using XView under MS-Windows
+
+1. Install the Cygwin development environment (freely available from
+   http://cygwin.com/), inlcuding the gcc, make, sunrpc, and xorg-x11-devel
+   packages.  This step is not optional -- XView cannot be built
+   or used under MS-Windows without Cygwin.  Specifically, mingw gcc and
+   other C compilers that do not use the Cygwin library will not work, because
+   XView is heavily dependent on the POSIX emulation provided by the Cygwin
+   library.
+
+   Illustrated instructions for installing Cygwin are available from
+	http://physionet.org/physiotools/cygwin/
+   An abbreviated version of these instructions can be found at the end
+   of this README.
+
+2. Click on the Cygwin icon to open a terminal window.  Perform
+   the remaining steps by typing commands in this window.
+
+3. If you have not already done so, download and unpack the tarball of
+   XView sources:
+	tar xfvz xview-3.2p1.4-19c.tar.gz
+
+4. Compile and install the XView libraries and clients:
+	cd xview-3.2p1.4-18c
+	bash Build-XView.bash libs instlibs clients instclients
+   
+   This procedure will take a long time and will generate thousands of lines
+   of progress and warning messages.  When it is complete, the libraries,
+   *.h files, and xview clients will all have been installed in subdirectories
+   of /usr/openwin (i.e., c:\cygwin\usr\openwin).  If you wish to copy the
+   binaries to another system, it is sufficient to copy the contents of
+   /usr/openwin.
+
+5. Add /usr/openwin/bin to your PATH before attempting to compile or run
+   any other XView applications.  To simplify running XView (and other X11
+   clients), it may be helpful to create a .bashrc file in your Cygwin home
+   directory containing these lines:
+	export PATH=/usr/openwin/bin:$PATH
+	export DISPLAY=:0.0
+
+6. Before attempting to run any XView application, start the X server if it
+   is not running already.  One way to do this is via
+	/usr/X11R6/bin/startxwin.bat
+   The version of this script that comes with Cygwin's xorg package runs the
+   X server with backing store disabled, which causes XView applications to
+   open with blank (solid white) windows. To avoid this problem, open
+   startxwin.bat in any text editor (Windows Notepad will work), and find the
+   line that reads
+	run XWin -multiwindow -clipboard -silent-dup-error
+   Add the option "+bs" to the end of this line, so that it reads
+	run XWin -multiwindow -clipboard -silent-dup-error +bs
+   If you have a two-button mouse, you will be able to simulate a middle
+   button click by "chording" (clicking both buttons at approximately the same
+   time) by using this form of the XWin command instead:
+        run XWin -multiwindow -clipboard -silent-dup-error +bs -emulate3buttons
+   Save startwin.bat.  If you make a desktop shortcut to this file, you can
+   click on it to launch the X server and an xterm window.
+
+   Note that this command will fail under recent versions of Windows if
+   another user previously ran the X server and left its log file in /tmp.
+   To fix this, delete the old log file before starting the X server:
+	rm -f /tmp/XWin.log
+
+7. Start any X applications using the appropriate commands in the xterm
+   window, or (if you have set DISPLAY as shown above) in the Cygwin terminal
+   window.  For example, the XView-based text editor can be launched by
+   typing
+	textedit
+
+------------------------------------------------------------------------------
+Installing Cygwin
+
+Cygwin is a free and open source GNU/Linux-like environment for all modern
+versions of MS-Windows (95/98/NT/2000/ME/XP) except for Windows CE. A vast
+number of optional packages can be installed as components of Cygwin, including
+everything necessary to compile and use XView, notably:
+    - gcc (the GNU compiler collection)
+    - make
+    - a high-quality X11R6 server, libraries, and clients
+    - sunrpc (interprocess communications used by XView)
+   
+1. Click on "Install Cygwin now" at http://cygwin.com/ to download
+   the Cygwin Net Release Setup Program (setup.exe), and run it.
+   Use the default answers for its initial questions ("Install from Internet",
+   root directory C:\cygwin, install for all users, and default text file type:
+   Unix).  Select your connection type, choose a download site from the list of
+   mirrors, and continue.
+
+2. At this point, the "Select Packages" dialog appears.  Click on
+   View to change from Category view to Full view.  Scroll through
+   the list of optional packages, selecting the packages to be installed
+   by clicking on the indicators in the "New" column until a package
+   version number appears. Be sure to select the gcc, make, sunrpc, and
+   xorg-x11-devel packages (the additional packages needed to satisfy the
+   dependencies of these packages will be installed automatically).
+
+   Select any other desired Cygwin packages, then click "Next" to
+   begin downloading and installing them.  Allow the installer to
+   create an icon on the desktop when it asks if you want one.
+
+   Clicking on the icon opens a Cygwin terminal emulator window.
+   Within the Cygwin window, you are running the bash shell, with
+   POSIX syntax (directory separators are '/', not '\').  The root
+   directory is visible to other MS-Windows applications as c:\cygwin.
+   The Cygwin installer will create a POSIX directory hierarchy
+   (containing, e.g., /bin, /etc, /home, and /usr directories) beneath
+   the root directory, and it will create subdirectories of /home as
+   home directories for each user.  To avoid problems, it is strongly
+   recommended that you avoid using directory names containing embedded
+   spaces.
+
+   If you wish to navigate through the rest of the Windows filesystem
+   from the Cygwin terminal, you may do so by starting at the special
+   directory named /cygdrive, like this:
+	cd /cygdrive
+   Within this directory, you will find a 'c' directory corresponding
+   to the Windows C drive, and additional directories for any other
+   drives that may be present.
+
--- origsrc/xview-3.2p1.4/README.X11R6	1994-06-27 03:22:18.000000000 +0100
+++ src/xview-3.2p1.4/README.X11R6	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-Some hints for building xview-3.2p1 on X11R6:
---------------------------------------------
-
-Tested environment:	Sun Sparcstation 2, sunos 4.1.2, standard cc
-			Sun Sparcstation IPX, sunos 4.1.3, standard cc
-
-If you did build your X11 with gcc and made it your default compiler
-in your X11 config files, you should take a look at config/XView.tmpl
-and uncomment the lines close to the end which say that it is only
-needed here (just search for lumpi)
-
-Installation:
-- Edit config/XView.cf for your path-settings
-- Follow the instructions in the top-level README
-- enjoy
-
-Changes made:
-- Read access to private gc structures were redone by calling
-  XGetGCValues
-- Access to display structure, such as the file descriptor were changed
-  to ConnectionNumber() or corresponding macros
-- Access to display structure defaults database was done with
-  XGetResourceDatabase (perhaps forgot the name - its 4am)
-- translate_key was reworked in some ugly way with XKeysymToString, i haven't
-  found any negative effects yet. 
-- All changes are marked with my email address, so you could just do a grep.
-  Everything in the libraries is #ifdef'd with X11R6. The corresponding
-  switch for R6 is in config/XView.cf - it is marked.
-
-Problems:
-- Internalizaion of more than level 3 (I18????) has not been tested.
-- Solaris 2.x is not supported since we don't run it here
-
-Known-Bugs:
-- Haven't found anything by now. Tested applications include the standard
-  clients such as cmdtool, olwm, clock etc. but also contributed software
-  such as ftptool.
-
-Warranty:
-- NONE
-
-License: 
-- The corresponding XVIEW Licenses applies. XView is a trademark of
-  SUN Microsystems as well as Open Look i believe.
-
-Have fun.
-
-Please email suggestions, fixes, bug-reports or thankfull greetings to me.
-
-Joern Lubkoll, lumpi@dobag.in-berlin.de
--- origsrc/xview-3.2p1.4/UNPACKING	1993-06-29 06:19:38.000000000 +0100
+++ src/xview-3.2p1.4/UNPACKING	1970-01-01 01:00:00.000000000 +0100
@@ -1,13 +0,0 @@
-To unpack this release:
-
-cat xview3.2.tar.Z.?? | uncompress | (cd sourcedir; tar xfp -)
-
-Release will be unpacked into ./xview3.2 and will look something
-like this:
-
-% ls xview3.2
-Building_with_gcc  contrib            misc              Imakefile
-UNPACKING          doc                util              LEGAL_NOTICE
-bitmaps            fonts              xview.man         Makefile
-clients            images             README            config
-lib
--- origsrc/xview-3.2p1.4/clients/olvwm-4.1/defaults.c	2013-02-23 14:43:37.484375000 +0000
+++ src/xview-3.2p1.4/clients/olvwm-4.1/defaults.c	2013-02-23 14:44:37.609375000 +0000
@@ -90,7 +90,7 @@ GetUserDefaults(dpy)
 #ifdef SVR4
 	    if (sysinfo(SI_HOSTNAME, hostname, sizeof(hostname)) != -1) {
 #else
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 	    if (0 == gethostname(hostname, sizeof(hostname))) {
 #else
 	    if (0 == gethostname(hostname, sizeof(hostname), &namelen)) {
--- origsrc/xview-3.2p1.4/clients/olvwm-4.1/olwm.c	2013-02-23 14:43:36.984375000 +0000
+++ src/xview-3.2p1.4/clients/olvwm-4.1/olwm.c	2013-02-23 14:44:37.609375000 +0000
@@ -649,13 +649,15 @@ cleanup()
 int
 RestartOLWM()
 {
-#ifndef SYSV
+#ifndef __CYGWIN__
+#ifndef SYSV 
 int     mask;
     mask = sigblock(SIGUSR1);
     sigsetmask(mask & ~(sigmask(SIGUSR1)));
 #else
     sigrelse(SIGUSR1);
 #endif
+#endif
     cleanup();
     execvp(argVec[0], argVec);
     ErrorGeneral("cannot restart");
@@ -687,7 +689,7 @@ handleChildSignal()
  *
  * mbuck@debian.org
  */
-#if (defined(SYSV) && !defined(SVR4)) || defined(__linux__)
+#if (defined(SYSV) && !defined(SVR4)) || defined(__linux__) || defined(__CYGWIN__)
 	signal(SIGCHLD, handleChildSignal);
 #endif
 #else
@@ -708,7 +710,7 @@ handleChildSignal()
 void
 ReapChildren()
 {
-#ifdef SYSV
+#if defined SYSV || defined __CYGWIN__
         pid_t pid;
         int status;
 #else
@@ -720,7 +722,7 @@ ReapChildren()
 	if (!deadChildren)
 		return;
 
-#ifdef SYSV
+#if defined SYSV || defined __CYGWIN__
 	sighold(SIGCHLD);
 #else
 	oldmask = sigblock(sigmask(SIGCHLD));
@@ -730,7 +732,7 @@ ReapChildren()
 
 	while (1) {
 
-#ifdef SYSV
+#if defined SYSV || defined __CYGWIN__
                 pid = waitpid(-1, &status, WNOHANG);
 #else
                 pid = wait3(&status, WNOHANG, (struct rusage *)0);
@@ -757,9 +759,9 @@ ReapChildren()
 
 	deadChildren = False;
 
-#ifdef SYSV
+#if defined SYSV 
 	sigrelse(SIGCHLD);
-#else
+#elif ! defined __CYGWIN__
         (void) sigsetmask(oldmask);
 #endif
 }
--- origsrc/xview-3.2p1.4/clients/olvwm-4.1/services.c	2013-02-23 14:43:37.218750000 +0000
+++ src/xview-3.2p1.4/clients/olvwm-4.1/services.c	2013-02-23 14:44:37.609375000 +0000
@@ -82,7 +82,7 @@ ExecCommand(env,cmd)
 	return 1;
     } else if (pid == 0) {
 	/* child */
-#if defined(SYSV) || defined(__linux__)
+#if defined(SYSV) || defined(__linux__) || defined(__CYGWIN__)
 	setpgrp();
 #else
 	setpgrp(0, getpid());
@@ -240,7 +240,7 @@ PshFunc(dpy, winInfo, menuInfo, idx)
 		close( pshPipe[1] );
 		close( 1 );		/* close stdout */
 		dup( 2 );		/* make olwm stderr = psh stdout */
-#if defined(SYSV) || defined(__linux__)
+#if defined(SYSV) || defined(__linux__) || defined(__CYGWIN__)
 		setpgrp();
 #else
 		setpgrp(0, getpid());
--- origsrc/xview-3.2p1.4/clients/olvwm-4.1/usermenu.c	2013-02-23 14:43:37.390625000 +0000
+++ src/xview-3.2p1.4/clients/olvwm-4.1/usermenu.c	2013-02-23 14:44:37.609375000 +0000
@@ -916,7 +916,7 @@ makeMenuSearchPath()
 	sprintf(buf, "%s/.%%s", home);
 	menuSearchPath[i++] = MemNewString(buf);
 	
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 	/* ++roman: /etc/X11/olvwm/<menufile> */
 	menuSearchPath[i++] = MemNewString("/etc/X11/olvwm/%s");
 #endif
--- origsrc/xview-3.2p1.4/clients/olvwm-4.1/usleep.c	2013-02-23 14:43:37.484375000 +0000
+++ src/xview-3.2p1.4/clients/olvwm-4.1/usleep.c	2013-02-23 14:44:37.625000000 +0000
@@ -70,8 +70,10 @@ olwm_usleep(usec)
 #else
 	sigpause(SIGALRM);
 	sigaction(SIGALRM, &old_vec, (struct sigaction *)0);
+#ifndef __CYGWIN__
 	sigrelse(SIGALRM);
 #endif
+#endif
 
 	setitimer(ITIMER_REAL, &old, (struct itimerval *)0);
 	return 0;
--- origsrc/xview-3.2p1.4/clients/olvwm-4.1/virtual.c	2013-02-23 14:43:37.234375000 +0000
+++ src/xview-3.2p1.4/clients/olvwm-4.1/virtual.c	2013-02-23 14:44:37.687500000 +0000
@@ -30,7 +30,7 @@
 #include "vdm.icon"
 #include "vdm.mask"
 
-#if defined(__linux__) && defined(__GLIBC__) && 0
+#if (defined(__linux__)||defined(__CYGWIN__)) && defined(__GLIBC__) && 0
 /* GNU libc doesn't use INIT, so we have to define sp ourselves. We have to
  * initialize it as well before we call compile(). Maybe this is a bug in
  * GNU libc, but I couldn't care less...
@@ -58,7 +58,10 @@ static regexp_err(int val);
 #define TRUE 1
 #define FALSE 0
 
+#ifndef __CYGWIN__
 #include <regexp.h>
+#endif
+
 #ifdef REGEXP
 regexp *expbuf;
 #endif
@@ -2021,7 +2024,7 @@ struct _menu	*menu;
 DIR	*dir;
 struct dirent	*ent;
 Button	*b;
-char	s[MAXNAMLEN], dirname[MAXPATHLEN - MAXNAMLEN], *newname, *ExpandPath();
+char	s[MAXNAMLEN], dirname[MAXPATHLEN - MAXNAMELEN], *newname, *ExpandPath();
 char	pattern[MAXNAMLEN];
 extern int AppMenuFunc();
 MenuCache	*menuCache;
@@ -2154,6 +2157,8 @@ rexMatch(string)
 {
 #ifdef REGEXP
     return regexec(expbuf, string);
+#elif defined __CYGWIN__
+    return NULL;
 #else
     return step(string,expbuf);
 #endif
@@ -2192,13 +2197,15 @@ char newPattern[256];
 #ifdef REGEXP
     expbuf = regcomp(newPattern);
 #else
-#if defined(__linux__) && defined(__GLIBC__)
+#if (defined(__linux__)||defined(__CYGWIN__)) && defined(__GLIBC__)
     /* See comment above.
      *
      * martin.buck@bigfoot.com
      */
 /*    sp = newPattern;*/
 #endif
+#ifndef __CYGWIN__
     compile(newPattern, expbuf, &expbuf[256], '\0');
 #endif
+#endif
 }
--- origsrc/xview-3.2p1.4/clients/olwm/defaults.c	2013-02-23 14:43:36.718750000 +0000
+++ src/xview-3.2p1.4/clients/olwm/defaults.c	2013-02-23 14:44:37.765625000 +0000
@@ -57,7 +57,7 @@ GetUserDefaults(dpy)
     char *homedir = getenv("HOME");
     char *envfile = getenv("XENVIRONMENT");
     char hostname[100];
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
     int namelen;
 #endif
 
@@ -82,7 +82,7 @@ GetUserDefaults(dpy)
 	if (homedir != NULL) {
 	    (void) strcpy(filename, homedir);
 	    (void) strcat(filename, "/.Xdefaults-");
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 	    if (0 == gethostname(hostname, sizeof(hostname), &namelen)) {
 #else
 	    if (0 == gethostname(hostname, sizeof(hostname))) {
--- origsrc/xview-3.2p1.4/clients/olwm/events.c	2013-02-23 14:43:36.437500000 +0000
+++ src/xview-3.2p1.4/clients/olwm/events.c	2013-02-23 14:44:37.765625000 +0000
@@ -579,7 +579,7 @@ AwaitEvents(dpy, timeout)
     if (timeout->tv_sec < 0)
 	return False;
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
     (void) gettimeofday(&starttime, NULL);
 #endif
 
@@ -615,7 +615,7 @@ AwaitEvents(dpy, timeout)
 	 * return an indication of valid data to the caller, yet also return
 	 * a value for the time remaining that is less than or equal to zero.
 	 */
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 /* Linux: select does the remaining time calculation for us. */
 	(void) gettimeofday(&curtime, NULL);
 	tvdiff(&starttime, &curtime, &diff1);
--- origsrc/xview-3.2p1.4/clients/olwm/gettext.c	2013-02-23 14:43:36.609375000 +0000
+++ src/xview-3.2p1.4/clients/olwm/gettext.c	2013-02-23 14:44:43.984375000 +0000
@@ -11,7 +11,7 @@
 
 #include "gettext.h"
 
-#if defined(__linux__) && !defined(LC_MESSAGES)
+#if (defined(__linux__) || defined(__CYGWIN__)) && !defined(LC_MESSAGES)
 #define LC_MESSAGES LC_RESPONSE
 #endif
 
@@ -19,14 +19,14 @@
 #define bzero(a,b) memset(a,0,b)
 #endif
 
-#if !defined(__linux__) || !defined(__GLIBC__)
+#if (!defined(__linux__) || !defined(__GLIBC__)) && !defined(__CYGWIN__)
 char *malloc(), *strdup();
 #endif
 char * dgettext(char *, char *);
 char *_gettext();
 char *in_path();
 char *fgets(), *getenv();
-#if !defined(__linux__) || !defined(__GLIBC__)
+#if (!defined(__linux__) || !defined(__GLIBC__)) && !defined(__CYGWIN__)
 caddr_t mmap(), calloc();
 #endif
 
--- origsrc/xview-3.2p1.4/clients/olwm/mem.c	2013-02-23 14:43:36.359375000 +0000
+++ src/xview-3.2p1.4/clients/olwm/mem.c	2013-02-23 14:44:37.781250000 +0000
@@ -137,7 +137,7 @@ MemAlloc(sz
 {
     void       *p;
 
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
     if (!sz)    /* Linux malloc(0) returns NULL, unlike BSD */
       sz = 1;
 #endif
--- origsrc/xview-3.2p1.4/clients/olwm/olwm.c	2013-02-23 14:43:36.453125000 +0000
+++ src/xview-3.2p1.4/clients/olwm/olwm.c	2013-02-23 14:44:37.843750000 +0000
@@ -45,7 +45,7 @@
 #include "error.h"
 #include "dsdm.h"
 
-#if defined(__linux__) && !defined(MAXPID)
+#if (defined(__linux__) || defined(__CYGWIN__))  && !defined(MAXPID)
 #define MAXPID 32767
 #endif
 
@@ -619,7 +619,7 @@ ExitOLWM()
 static void
 handleChildSignal()
 {
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 /* Reinitialize signal catcher */
 	signal(SIGCHLD, handleChildSignal);
 #endif
@@ -634,7 +634,7 @@ handleChildSignal()
 void
 ReapChildren()
 {
-#ifdef SYSV
+#if defined SYSV || defined __CYGWIN__
         pid_t pid;
         int status;
 #else
@@ -645,7 +645,7 @@ ReapChildren()
 
 	if (!deadChildren)
 		return;
-#ifdef SYSV
+#if defined SYSV || defined __CYGWIN__
 	sighold(SIGCHLD);
 #else
 	oldmask = sigblock(sigmask(SIGCHLD));
@@ -655,7 +655,7 @@ ReapChildren()
 
 	while (1) {
 
-#ifdef SYSV
+#if defined SYSV || defined __CYGWIN__
                 pid = waitpid(-1, &status, WNOHANG);
 #else
                 pid = wait3(&status, WNOHANG, (struct rusage *)0);
@@ -682,9 +682,9 @@ ReapChildren()
 
 	deadChildren = False;
 
-#ifdef SYSV
+#if defined SYSV 
 	sigrelse(SIGCHLD);
-#else
+#elif ! defined __CYGWIN__
         (void) sigsetmask(oldmask);
 #endif
 }
--- origsrc/xview-3.2p1.4/clients/olwm/resources.c	2013-02-23 14:43:36.625000000 +0000
+++ src/xview-3.2p1.4/clients/olwm/resources.c	2013-02-23 14:44:37.843750000 +0000
@@ -40,7 +40,7 @@
 #include "events.h"
 #include "error.h"
 
-#if defined(__linux__) && !defined(LC_MESSAGES)
+#if (defined(__linux__) || defined(__CYGWIN__)) && !defined(LC_MESSAGES)
 #define LC_MESSAGES LC_RESPONSE
 #endif
 
--- origsrc/xview-3.2p1.4/clients/olwm/services.c	2013-02-23 14:43:36.593750000 +0000
+++ src/xview-3.2p1.4/clients/olwm/services.c	2013-02-23 14:44:37.859375000 +0000
@@ -80,7 +80,7 @@ execCommand(winInfo,cmd)
 	return 1;
     } else if (pid == 0) {
 	/* child */
-#if defined(SYSV) || defined(__linux__)
+#if defined(SYSV) || defined(__linux__) || defined(__CYGWIN__)
 	setpgrp();
 #else
 	setpgrp(0, getpid());
@@ -238,7 +238,7 @@ PshFunc(dpy, winInfo, menuInfo, idx)
 		close( pshPipe[1] );
 		close( 1 );		/* close stdout */
 		dup( 2 );		/* make olwm stderr = psh stdout */
-#if defined(SYSV) || defined(__linux__)
+#if defined(SYSV) || defined(__linux__) || defined(__CYGWIN__)
 		setpgrp();
 #else
 		setpgrp(0, getpid());
--- origsrc/xview-3.2p1.4/clients/olwm/slave.c	2013-02-23 14:43:36.531250000 +0000
+++ src/xview-3.2p1.4/clients/olwm/slave.c	2013-02-23 14:44:37.859375000 +0000
@@ -87,7 +87,7 @@ SlaveStart(argv)
 	case 0:				/* Slave */
 		dup2(input[0],0);
 		dup2(output[1],1);
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 		if (getrlimit(RLIMIT_NOFILE,&rlimit) == -1)
 			maxfd = 0;
 		else
--- origsrc/xview-3.2p1.4/clients/olwm/usermenu.c	2013-02-23 14:43:36.609375000 +0000
+++ src/xview-3.2p1.4/clients/olwm/usermenu.c	2013-02-23 14:44:37.859375000 +0000
@@ -756,7 +756,7 @@ makeMenuSearchPath()
 	sprintf(buf, "%s/.%%s", home);
 	menuSearchPath[i++] = MemNewString(buf);
 	
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 	/* ++roman: /etc/X11/olwm/<menufile> */
 	menuSearchPath[i++] = MemNewString("/etc/X11/olwm/%s");
 #endif
--- origsrc/xview-3.2p1.4/clients/olwm/usleep.c	2013-02-23 14:43:36.718750000 +0000
+++ src/xview-3.2p1.4/clients/olwm/usleep.c	2013-02-23 14:44:37.859375000 +0000
@@ -70,8 +70,10 @@ olwm_usleep(usec)
 #else
 	sigpause(SIGALRM);
 	sigaction(SIGALRM, &old_vec, (struct sigaction *)0);
+#ifndef __CYGWIN__
 	sigrelse(SIGALRM);
 #endif
+#endif
 
 	setitimer(ITIMER_REAL, &old, (struct itimerval *)0);
 	return 0;
--- origsrc/xview-3.2p1.4/clients/olwmslave/Imakefile	2013-02-23 14:43:36.812500000 +0000
+++ src/xview-3.2p1.4/clients/olwmslave/Imakefile	2013-02-23 14:44:37.859375000 +0000
@@ -6,7 +6,7 @@ XCOMM # Imakefile for olwmslave release
 
 #define HasInfoFiles YES
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 DEFINES =  $(XVCLIENTDEFINES)
 #else
 DEFINES =  $(XVCLIENTDEFINES) -DOW_I18N_L3
--- origsrc/xview-3.2p1.4/clients/props/l10n_props.c	2013-02-23 14:43:37.671875000 +0000
+++ src/xview-3.2p1.4/clients/props/l10n_props.c	2013-02-23 14:44:37.859375000 +0000
@@ -22,7 +22,7 @@ static char *sccsid = "@(#)l10n_props.c
 #define bcopy(a,b,c) memmove(b,a,c)
 #endif
 
-#if defined __linux__ && !defined LC_MESSAGES
+#if (defined(__linux__) || defined(__CYGWIN__)) && !defined LC_MESSAGES
 #define LC_MESSAGES LC_RESPONSE
 #endif
 
--- origsrc/xview-3.2p1.4/clients/props/l10n_read.c	2013-02-23 14:43:37.656250000 +0000
+++ src/xview-3.2p1.4/clients/props/l10n_read.c	2013-02-23 14:44:37.859375000 +0000
@@ -25,7 +25,7 @@ static char *sccsid = "@(#)l10n_read.c 1
 #define	ITEM_SEPARATOR		';'
 
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 #ifndef ultrix
 extern char	*malloc();
 #endif
--- origsrc/xview-3.2p1.4/clients/textedit/textedit.c	2013-02-23 14:43:36.734375000 +0000
+++ src/xview-3.2p1.4/clients/textedit/textedit.c	2013-02-23 14:44:37.859375000 +0000
@@ -12,7 +12,11 @@ static char sccsid[] = "@(#)textedit.c 1
  */
 
 #include <sys/param.h> /* MAXPATHLEN (include types.h if removed) */
+#ifndef __CYGWIN__
 #include <sys/dir.h>   /* MAXNAMLEN */
+#else
+#include <dirent.h>
+#endif
 #include <sys/stat.h>
 
 #include <fcntl.h>
@@ -41,7 +45,7 @@ static char sccsid[] = "@(#)textedit.c 1
 long	textsw_store_file();
 */
 char	*getwd();
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 char *sprintf();
 #endif
 void	frame_cmdline_help();
@@ -822,10 +826,10 @@ textedit_main(argc, argv)
 	 * Setup signal handlers.
 	 */
 	(void)notify_set_signal_func(base_frame, mysigproc, SIGINT,  NOTIFY_ASYNC);
-#if !defined(__linux__) || defined(SIGXCPU)
+#if !(defined(__linux__) || defined(__CYGWIN__)) || defined(SIGXCPU)
 	(void)notify_set_signal_func(base_frame, mysigproc, SIGXCPU, NOTIFY_ASYNC);
 #endif
-#if !defined(__linux__) || defined(SIGBUS)
+#if !(defined(__linux__) || defined(__CYGWIN__)) || defined(SIGBUS)
 	(void)notify_set_signal_func(base_frame, mysigproc, SIGBUS,  NOTIFY_ASYNC);
 #endif
 	(void)notify_set_signal_func(base_frame, mysigproc, SIGHUP,  NOTIFY_ASYNC);
@@ -913,7 +917,7 @@ mysigproc(me, sig, when)
 	char			 name_to_use[MAXNAMLEN];
 	int			 pid = getpid();
 	int			 was_SIGILL = (sig == SIGILL);
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 	struct sigvec vec;
 #else
 	struct sigaction vec;
@@ -969,12 +973,14 @@ Done:
 Die:
 	(void)fprintf(stderr, "aborting for post-mortem ...\n");
 	(void)fflush(stderr);
-	(void)sigsetmask(0);		/* Make sure signals get through */
+#ifndef __CYGWIN__
+	(void)sigsetmask(0);		/* Make sure signalas get through */
+#endif
 	if (was_SIGILL) {
 #ifndef lint
 	    char	dummy, *bad_ptr = 0;
 	    /* (void)signal(SIGSEGV, SIG_DFL);	/* Make sure 0 deref dumps. */
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 	    vec.sv_handler = SIG_DFL;
 	    vec.sv_mask = vec.sv_onstack = 0;
 	    sigvec(SIGSEGV, &vec, 0);
@@ -997,7 +1003,7 @@ Die:
 #endif
 	} else {
 	    /* (void)signal(SIGILL, SIG_DFL);	/* Make sure abort() dumps. */
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
             vec.sv_handler = SIG_DFL; 
 	    vec.sv_mask = vec.sv_onstack = 0; 
             sigvec(SIGILL, &vec, 0);
--- origsrc/xview-3.2p1.4/config/XView.cf	2013-02-23 14:43:36.359375000 +0000
+++ src/xview-3.2p1.4/config/XView.cf	2013-02-23 14:44:37.875000000 +0000
@@ -54,6 +54,12 @@ XCOMM # XView.cf for XView release 3.0.
 #undef __linux__
 #define __linux__ 1
 #endif
+
+#if defined(cygwinArchitecture) || defined(cygwin)
+#undef __CYGWIN__
+#define __CYGWIN__ 1
+#endif
+
 #if defined(i386Architecture) || defined(i386)
 #undef __i386
 #define __i386 1
@@ -190,7 +196,7 @@ XCOMM # XView.cf for XView release 3.0.
  *	scripts, set the following value to YES below.
  */
 #ifndef InstallConversion
-#define InstallConversion YES
+#define InstallConversion NO
 #endif
 /*
  *	If you are using SunOS 3.5 or another 4.2 BSD based operating system,
@@ -211,12 +217,14 @@ XCOMM # XView.cf for XView release 3.0.
 # if PreR4Server
 # define LibXViewDefines -DPRE_R4_ICCCM
 # else
-#  ifdef __linux__
+#  if defined __linux__
 #   ifdef __i386
 #    define LibXViewDefines -I$(OPENWINHOME)/include -DX11R6 -Di386 -DNO_CAST_VATOAV
 #   else
 #    define LibXViewDefines -I$(OPENWINHOME)/include -DX11R6 -DNO_CAST_VATOAV
 #   endif
+#  elif defined __CYGWIN__
+#    define LibXViewDefines -I$(OPENWINHOME)/include -DX11R6 -Di386 -DNO_CAST_VATOAV
 #  else
 #   define LibXViewDefines -DFULL_R5 -I$(OPENWINHOME)/include -DSUNOS41 -DX11R6
 #  endif
@@ -384,7 +392,11 @@ XCOMM # XView.cf for XView release 3.0.
  *    	be defined as -PIC
  */
 #ifndef PositionIndependentCodeFlag
+#ifndef __CYGWIN__
 #define PositionIndependentCodeFlag -fPIC
+#else
+#define PositionIndependentCodeFlag
+#endif
 #endif
 
 /*
--- origsrc/xview-3.2p1.4/config/XView.obj	2013-02-23 14:43:36.343750000 +0000
+++ src/xview-3.2p1.4/config/XView.obj	2013-02-23 14:44:37.937500000 +0000
@@ -55,7 +55,7 @@ NormalLibraryObjectRule()
  */
 #if SharedLibXView
 
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 SubdirNormalSharedLibraryTarget(${LIBTARGET},${SOREV},$(OBJS),$(SHARED_DIR),shared)
 
 #else /* __linux__ */
--- origsrc/xview-3.2p1.4/config/XView.rules	2013-02-23 14:43:36.281250000 +0000
+++ src/xview-3.2p1.4/config/XView.rules	2013-02-23 14:45:44.609375000 +0000
@@ -13,37 +13,51 @@ XCOMM # XView.rules for XView release 3.
 /*
  * SubdirNormalLibTarget - create an "all::" target for a library;
  */
+
 #ifndef SubdirNormalLibTarget
+#ifndef __CYGWIN__							
 #define SubdirNormalLibTarget(libname, objlist)				@@\
 AllTarget(lib/**/libname.a)						@@\
 									@@\
 lib/**/libname.a:: objlist						@@\
 	$(AR) $(TARGETDIR)$@ objlist
 
+#else
+#define SubdirNormalLibTarget(libname, objlist)				@@\
+
+#endif 
 #endif /* SubdirNormalLibTarget */
 
 /*
  * SubdirProfiledLibTarget - create an "all::" target for a profiled library;
  */
 #ifndef SubdirProfiledLibTarget
+#ifndef __CYGWIN__
 #define SubdirProfiledLibTarget(libname, objlist)			@@\
 AllTarget(lib/**/libname/**/_p.a)					@@\
 									@@\
 lib/**/libname/**/_p.a:: objlist					@@\
 	( cd profiled; $(AR) ../$(TARGETDIR)$@ objlist )
+#else
+#define SubdirProfiledLibTarget(libname, objlist)			@@\
 
+#endif
 #endif /* SubdirProfiledLibTarget */
 
 /*
  * SubdirDebuggedLibTarget - create an "all::" target for a debugged library;
  */
 #ifndef SubdirDebuggedLibTarget
+#ifndef __CYGWIN__
 #define SubdirDebuggedLibTarget(libname, objlist)			@@\
 AllTarget(lib/**/libname/**/_d.a)					@@\
 									@@\
 lib/**/libname/**/_d.a:: objlist					@@\
 	( cd debugger; $(AR) ../$(TARGETDIR)$@ objlist )
+#else
+#define SubdirDebuggedLibTarget(libname, objlist)			@@\
 
+#endif
 #endif /* SubdirDebuggedLibTarget */
 
 /*
@@ -51,14 +65,19 @@ lib/**/libname/**/_d.a:: objlist					@@\
  * --same rule as SubdirNormalLibTarget--compatibility
  */
 #ifndef SubdirCompoundLibTarget
+#ifndef __CYGWIN__
 #define SubdirCompoundLibTarget(libname, objlist)			@@\
 AllTarget(lib/**/libname.a)						@@\
 									@@\
 lib/**/libname.a:: objlist						@@\
 	$(AR) $(TARGETDIR)$@ objlist
+#else
+#define SubdirCompoundLibTarget(libname, objlist)			@@\
 
+#endif
 #endif /* SubdirCompoundLibTarget */
 
+
 /* 
  * MakeAnythingSubdirs - go into subdirs to make anything for a given target;
  */
@@ -104,7 +123,7 @@ install:: 								@@\
  * shared library directory for all objects in solist.
  */
 #ifndef SubdirNormalSharedLibraryTarget
-#ifdef __linux__
+#if defined __linux__ 
 #define SubdirNormalSharedLibraryTarget(libname,rev,solist,dir,sub)	@@\
 AllTarget(lib/**/libname.so.rev)					@@\
 									@@\
@@ -114,6 +133,16 @@ lib/**/libname.so.rev::  solist						@@\
 	pwd="`pwd`"; \							@@\
 	for i in solist; do (set -x; $(RM) dir/$$i; $(LN) "$$pwd"/sub/$$i dir/$$i); done
 
+#elif defined __CYGWIN__
+#define SubdirNormalSharedLibraryTarget(libname,rev,solist,dir,sub)	@@\
+AllTarget(cyg/**/libname-rev.dll)					@@\
+									@@\
+cyg/**/libname-rev.dll::  solist					@@\
+	-@if [ ! -d dir ]; then mkdir dir; else exit 0; fi		@@\
+	@case '${MFLAGS}' in *[i]*) set +e;; esac; \			@@\
+	pwd="`pwd`"; \							@@\
+	for i in solist; do (set -x; $(RM) dir/$$i; $(LN) "$$pwd"/sub/$$i dir/$$i); done
+
 #else /* __linux__ */
 #define SubdirNormalSharedLibraryTarget(libname,rev,solist,dir,sub)	@@\
 AllTarget(lib/**/libname.so.rev)					@@\
@@ -133,7 +162,7 @@ lib/**/libname.so.rev::  solist						@@\
  * unneeded data modules from the ./shared directory.
  */
 #ifndef SubdirNormalSharedLibraryDataTarget
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 #define SubdirNormalSharedLibraryDataTarget(libname,rev,salist,dir,sub)
 #else /* __linux__ */
 #define SubdirNormalSharedLibraryDataTarget(libname,rev,salist,dir,sub)	@@\
@@ -157,7 +186,7 @@ lib/**/libname.sa.rev::  salist						@@\
  * included in both the .so and the .sa parts of the library.
  */
 #ifndef SubdirBuildNormalSharedLibraryTarget
-#ifdef __linux__
+#if defined __linux__ 
 
 #define SubdirBuildNormalSharedLibraryTarget(libname,rev,solist,sodir)		@@\
 AllTarget(lib/**/libname.so.rev)					@@\
@@ -174,6 +203,23 @@ lib/**/libname.so.rev:: solist 						@@\
 clean::	@@\
 	$(RM) lib/**/libname.so.rev `basename lib/**/libname.so.rev | sed 's/\(\.[0-9]\).*$$/\1/'` lib/**/libname.so sodir/?*.o
 
+#elif defined __CYGWIN__
+
+#define SubdirBuildNormalSharedLibraryTarget(libname,rev,solist,sodir)			@@\
+AllTarget(cyg/**/libname-rev.dll)							@@\
+											@@\
+cyg/**/libname-rev.dll:: solist 							@@\
+	$(RM) $@									@@\
+	(cd sodir; $(CC) -shared -o $@ ?*.o $(XVIEW_DEPLIBS) -lrpc -Wl,--out-implib=lib/**/libname-rev.dll.a)	@@\
+	$(MV) sodir/$@ $@ @@\
+	$(MV) sodir/lib/**/libname-rev.dll.a lib/**/libname-rev.dll.a @@\
+	$(LN) lib/**/libname-rev.dll.a lib/**/libname.a
+	
+@@\
+@@\
+clean::	@@\
+	$(RM) cyg/**/libname-rev.dll lib/**/libname.a lib/**/libname-rev.dll.a sodir/?*.o
+
 #else /* __linux__ */
 
 #define SubdirBuildNormalSharedLibraryTarget(libname,rev,solist,sodir)		@@\
@@ -204,7 +250,7 @@ clean::									@@\
  * sorting script and a list of objects to sort.
  */
 #ifndef SubdirBuildSortedSharedLibraryTarget
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 
 #define SubdirBuildSortedSharedLibraryTarget(libname,rev,solist,sodir,objsort,objlist) \
 		SubdirBuildNormalSharedLibraryTarget(libname,rev,solist,sodir)
@@ -240,7 +286,7 @@ clean::									@@\
 
 #ifndef SubdirBuildNormalSharedLibraryDataTarget
 
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 #define SubdirBuildNormalSharedLibraryDataTarget(libname,rev,sadir)
 
 #else /* __linux__ */
@@ -264,7 +310,7 @@ clean::									@@\
 #else /* DoRanlibCmd */
 
 #ifndef SubdirBuildNormalSharedLibraryDataTarget
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 #define SubdirBuildNormalSharedLibraryDataTarget(libname,rev,sadir)
 #else /* __linux__ */
 #define SubdirBuildNormalSharedLibraryDataTarget(libname,rev,sadir)	@@\
@@ -291,7 +337,7 @@ clean::									@@\
  * overflow the GLOBAL_OFFSET_TABLE for some architectures.
  */
 #ifndef SubdirSharedLibraryObjectRule
-#ifdef __linux__
+#if defined __linux__ 
 #define SubdirSharedLibraryObjectRule()					@@\
 all::									@@\
 	-@if [ ! -d shared ]; then mkdir shared; else exit 0; fi	@@\
@@ -309,6 +355,23 @@ clean::									@@\
 	$(RM) strings*							@@\
 	-@if [ -d shared ]; then echo "	$(RM) shared/?*.o"; \		@@\
 		$(RM) shared/?*.o; else exit 0; fi			@@\
+#elif  defined __CYGWIN__
+#define SubdirSharedLibraryObjectRule()					@@\
+all::									@@\
+	-@if [ ! -d shared ]; then mkdir shared; else exit 0; fi	@@\
+	-@if [ ! -f $(XSTR_STRINGS_FILE) ]; then \                      @@\
+		touch $(XSTR_STRINGS_FILE);  else exit 0; fi            @@\
+	-@if [ ! -f strings ]; then \                                   @@\
+		$(LN) $(XSTR_STRINGS_FILE) strings; else exit 0; fi     @@\
+									@@\
+.c.o:									@@\
+	$(CC) $(SHAREDCODEDEF) $(SHLIBDEF) $(CFLAGS) $(STRCONST) -c $*.c -o shared/$*.o	@@\
+	$(CC) $(CFLAGS) $(STRCONST) -c $*.c -o $*.o			@@\
+									@@\
+clean::									@@\
+	$(RM) strings*							@@\
+	-@if [ -d shared ]; then echo "	$(RM) shared/?*.o"; \		@@\
+		$(RM) shared/?*.o; else exit 0; fi			@@\
 
 #else /* __linux__ */
 #define SubdirSharedLibraryObjectRule()					@@\
@@ -367,6 +430,7 @@ clean::									@@\
  * This rule does not use xstr so it may be used for data modules.
  */
 #ifndef SubdirSpecialSharedAndDebuggedObjectRule
+#ifdef __CYGWIN__
 #define	SubdirSpecialSharedAndDebuggedObjectRule(objs,depends,options)	@@\
 all::									@@\
 	-@if [ ! -d shared ]; then mkdir shared; else exit 0; fi	@@\
@@ -374,12 +438,26 @@ all::									@@\
 									@@\
 objs:	depends								@@\
 	$(RM) $@ shared/$@ debugger/$@					@@\
-	$(CC) $(PIC) -c $(SHAREDCODEDEF) $(SHLIBDEF) $(CFLAGS) options $*.c @@\
+	$(CC) -c $(SHAREDCODEDEF) $(SHLIBDEF) $(CFLAGS) options $*.c @@\
 	$(CP) $*.o shared/$*.o						@@\
 	$(CC) -g -c $(SHLIBDEF) $(CFLAGS) options $*.c			@@\
 	$(CP) $*.o debugger/$*.o					@@\
 	$(CC) -c $(SHLIBDEF) $(CFLAGS) options $*.c
 
+#else /* cygwin */
+#define	SubdirSpecialSharedAndDebuggedObjectRule(objs,depends,options)	@@\
+all::									@@\
+	-@if [ ! -d shared ]; then mkdir shared; else exit 0; fi	@@\
+	-@if [ ! -d debugger ]; then mkdir debugger; else exit 0; fi	@@\
+									@@\
+objs:	depends								@@\
+	$(RM) $@ shared/$@ debugger/$@					@@\
+	$(CC) $(PIC) -c $(SHAREDCODEDEF) $(SHLIBDEF) $(CFLAGS) options $*.c @@\
+	$(CP) $*.o shared/$*.o						@@\
+	$(CC) -g -c $(SHLIBDEF) $(CFLAGS) options $*.c			@@\
+	$(CP) $*.o debugger/$*.o					@@\
+	$(CC) -c $(SHLIBDEF) $(CFLAGS) options $*.c
+#endif
 #endif /* SubdirSpecialDebuggedAndProfiledObjectRule */
 
 /*
@@ -388,16 +466,28 @@ objs:	depends								@@\
  * This rule does not use xstr so it may be used for data modules.
  */
 #ifndef SubdirSpecialSharedObjectRule
+#ifdef __CYGWIN__
 #define	SubdirSpecialSharedObjectRule(objs,depends,options)		@@\
 all::									@@\
 	-@if [ ! -d shared ]; then mkdir shared; else exit 0; fi	@@\
 									@@\
 objs:	depends								@@\
 	$(RM) $@ shared/$@ 						@@\
-	$(CC) $(PIC) -c $(SHAREDCODEDEF) $(SHLIBDEF) $(CFLAGS) options $*.c @@\
+	$(CC) -c $(SHAREDCODEDEF) $(SHLIBDEF) $(CFLAGS) options $*.c @@\
 	$(CP) $*.o shared/$*.o						@@\
 	$(CC) -c $(SHLIBDEF) $(CFLAGS) options $*.c
 
+#else /* cygwin */
+#define	SubdirSpecialSharedObjectRule(objs,depends,options)		@@\
+all::									@@\
+	-@if [ ! -d shared ]; then mkdir shared; else exit 0; fi	@@\
+									@@\
+objs:	depends								@@\
+	$(RM) $@ shared/$@ 						@@\
+	$(CC) $(PIC) -c $(SHAREDCODEDEF) $(SHLIBDEF) $(CFLAGS) options $*.c @@\
+	$(CP) $*.o shared/$*.o						@@\
+	$(CC) -c $(SHLIBDEF) $(CFLAGS) options $*.c
+#endif 
 #endif /* SubdirSpecialSharedObjectRule */
 
 /*
@@ -415,7 +505,7 @@ objs:	depends								@@\
  * InstallSharedLibraryDataNoBuild - rules to install the shared library data
  * Check if ranlib is needed
  */
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN___
 #define	InstallSharedLibraryDataNoBuild(libname,rev,dest)
 #else /* __linux__ */
 #if DoRanlibCmd
@@ -445,7 +535,7 @@ install:: 								@@\
  * InstallSharedLibraryNoBuild - generate rules to install the shared library.
  */
 #ifndef InstallSharedLibraryNoBuild
-#ifdef __linux__
+#if defined __linux__
 #define	InstallSharedLibraryNoBuild(libname,rev,dest)			@@\
 install::  								@@\
 	$(RM) $(DESTDIR)dest/lib/**/libname.so				@@\
@@ -453,6 +543,17 @@ install::  								@@\
 	(cd $(DESTDIR)dest && $(LN) lib/**/libname.so.rev lib/**/libname.so) @@\
 	(PATH=$$PATH:/sbin:/usr/sbin && ldconfig -v -N -l $(DESTDIR)dest/lib/**/libname.so.rev)
 
+#elif  defined __CYGWIN__
+#define	InstallSharedLibraryNoBuild(libname,rev,dest)			@@\
+install::  								@@\
+	$(RM) $(DESTDIR)dest/lib/**/libname-rev.dll.a				@@\
+	$(INSTALL) $(INSTSHAREDLIBFLAGS) lib/**/libname-rev.dll.a $(DESTDIR)dest @@\
+	(cd $(DESTDIR)dest && $(LN) -f lib/**/libname-rev.dll.a lib/**/libname.a) @@\
+	mkdir -p $(BINDIR) @@\
+	$(RM) $(BINDIR)/cyg/**/libname-rev.dll				@@\
+	$(INSTALL) cyg/**/libname-rev.dll $(BINDIR) @@\
+
+
 #else /* __linux__ */
 #define	InstallSharedLibraryNoBuild(libname,rev,dest)			@@\
 install::  								@@\
--- origsrc/xview-3.2p1.4/config/XView.tmpl	2013-02-23 14:43:36.359375000 +0000
+++ src/xview-3.2p1.4/config/XView.tmpl	2013-02-23 14:44:38.015625000 +0000
@@ -96,7 +96,7 @@ XCOMM # rules to those supplied with X V
 /*
  *      Work around small conflict with Project.tmpl file
  */
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 #if UseInstalled
             MKDIRHIER = BourneShell BinDir/mkdirhier
 #endif
@@ -330,7 +330,11 @@ XCOMM # rules to those supplied with X V
  *	These rules would be very handy for the site.def file.
  */
 #if SharedLibXView
-            DEPXVIEWLIB =
+#ifdef __CYGWIN__
+            DEPXVIEWLIB = -lrpc
+#else
+	    DEPXVIEWLIB =
+#endif
                XVIEWLIB = -L$(LIBRARY_DEST) -lxview
 #else
             DEPXVIEWLIB = _Use($(LIBRARY_DEST),$(XVLIBSRC)/libxview)/libxview.a
@@ -351,12 +355,22 @@ XCOMM # rules to those supplied with X V
                XVPSLIB = LoaderLibPrefix -L$(LIBRARY_DEST) -lxvps
 #endif
 
+/* Linux implementation of SVR4 (UNIX98) ptys requires libutil -- not
+ * checked on other platforms.
+ */
+#ifndef __linux__
 #if SharedLibX
              XLIB = $(EXTENSIONLIB) -lX11
 #else
              XLIB = $(EXTENSIONLIB) LoaderLibPrefix -lX11
 #endif
-
+#else
+#if SharedLibX
+             XLIB = $(EXTENSIONLIB) -lX11 -lutil
+#else
+             XLIB = $(EXTENSIONLIB) LoaderLibPrefix -lX11 -lutil
+#endif
+#endif
 
 #if SystemV4
              SYSV_CLIENT_LIB = -lintl -ldl
@@ -414,7 +428,7 @@ XCOMM # rules to those supplied with X V
  */
 #if SharedLibXView
 # ifndef SharedXViewRev
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 #define SharedXViewRev 3.2.4
 #else
 #if SystemV4
--- origsrc/xview-3.2p1.4/contrib/examples/extensions/Bitmap.c	1993-06-29 06:13:32.000000000 +0100
+++ src/xview-3.2p1.4/contrib/examples/extensions/Bitmap.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,189 +0,0 @@
-/*
- * Bitmap.c -- an XView object class that displays an arbitrary
- * pixmap.  This is similar to the Logo object, but the programmer
- * may specify the bitmap to use via the BITMAP_FILE attribute.
- */
-#include "bitmap_impl.h"
-#include <xview/notify.h>
-#include <xview/cms.h>
-#include <X11/Xutil.h>
-
-/* declare the "methods" used by the bitmap class. */
-static int bitmap_init(), bitmap_destroy();
-static Xv_opaque bitmap_set(), bitmap_get();
-static void bitmap_repaint();
-
-Xv_pkg bitmap_pkg = {
-    "Bitmap2",               /* package name */
-    ATTR_PKG_BITMAP,         /* package ID */
-    sizeof(Bitmap_public),   /* size of the public struct */
-    WINDOW,                  /* subclassed from the window package */
-    bitmap_init,
-    bitmap_set,
-    bitmap_get,
-    bitmap_destroy,
-    NULL                     /* disable the use of xv_find() */
-};
-
-static void
-bitmap_redraw(bitmap_public, event)
-Bitmap_public     *bitmap_public;
-Event           *event;
-{
-    Bitmap_private *bitmap_private = BITMAP_PRIVATE(bitmap_public);
-    XEvent *xevent = event_xevent(event);
-
-    if (bitmap_private->bitmap &&
-        xevent->xany.type == Expose && xevent->xexpose.count == 0) {
-        Display *dpy = (Display *)xv_get(bitmap_public, XV_DISPLAY);
-        Window window = (Window)xv_get(bitmap_public, XV_XID);
-        int width = (int)xv_get(bitmap_public, XV_WIDTH);
-        int height = (int)xv_get(bitmap_public, XV_HEIGHT);
-        int x = (width - bitmap_private->width)/2;
-        int y = (height - bitmap_private->height)/2;
-
-        XCopyPlane(dpy, bitmap_private->bitmap, window,
-            bitmap_private->gc, 0, 0, bitmap_private->width,
-            bitmap_private->height, x, y, 1L);
-    } else if (xevent->xany.type == ConfigureNotify)
-        XClearArea(xv_get(bitmap_public, XV_DISPLAY),
-            xv_get(bitmap_public, XV_XID), 0, 0,
-            xevent->xconfigure.width, xevent->xconfigure.height,
-            True);
-}
-
-/* initialize the bitmap object by creating (alloc) an instance
- * of it.  There are two parts to an object class: a public part
- * and a private part.  Each contains a pointer to the other, so
- * link the two together and initialize the remaining fields of
- * the bitmap data structure.  Do no initialize the bitmap's GC
- * because it is dependent on its window's cms and that isn't
- * assigned to the window till the "set" method.  Also, wait till
- * till the "set" method to initialize the bitmap file specified.
- */
-static int
-bitmap_init(owner, bitmap_public, avlist)
-Xv_opaque       owner;
-Bitmap_public     *bitmap_public;
-Attr_avlist     avlist; /* ignored here */
-{
-    Bitmap_private *bitmap_private = xv_alloc(Bitmap_private);
-
-    if (!bitmap_private)
-        return XV_ERROR;
-
-    /* link the public to the private and vice-versa */
-    bitmap_public->private_data = (Xv_opaque)bitmap_private;
-    bitmap_private->public_self = (Xv_opaque)bitmap_public;
-
-    /* set up event handlers to get resize and repaint events */
-    xv_set(bitmap_public,
-        WIN_NOTIFY_SAFE_EVENT_PROC,      bitmap_redraw,
-        WIN_NOTIFY_IMMEDIATE_EVENT_PROC, bitmap_redraw,
-        NULL);
-
-    return XV_OK;
-}
-
-/* bitmap_set() -- the function called to set attributes in a bitmap
- * object.  This function is called when a bitmap is created after
- * the init routine as well as when the programmer calls xv_set.
- */
-static Xv_opaque
-bitmap_set(bitmap_public, avlist)
-Bitmap_public *bitmap_public;
-Attr_avlist avlist;
-{
-    Bitmap_private *bitmap_private = BITMAP_PRIVATE(bitmap_public);
-    Attr_attribute *attrs;
-
-    for (attrs = avlist; *attrs; attrs = attr_next(attrs))
-        switch ((int) attrs[0]) {
-            case BITMAP_FILE : {
-                int val, x, y;
-                Display *dpy =
-                    (Display *)xv_get(bitmap_public, XV_DISPLAY);
-                Window window =
-                    (Window)xv_get(bitmap_public, XV_XID);
-                Pixmap old = bitmap_private->bitmap;
-                if (XReadBitmapFile(dpy, window, attrs[1],
-                    &bitmap_private->width, &bitmap_private->height,
-                    &bitmap_private->bitmap, &x, &y) != BitmapSuccess)
-                {
-                    xv_error(bitmap_public,
-                        ERROR_STRING, "Unable to load bitmap file",
-                        ERROR_PKG,    BITMAP,
-                        NULL);
-                    bitmap_private->bitmap = old;
-                }
-                break;
-            }
-            case BITMAP_PIXMAP :
-                xv_error(bitmap_public,
-                    ERROR_CANNOT_SET, attrs[0],
-                    ERROR_PKG,        BITMAP,
-                    NULL);
-                break;
-            case XV_END_CREATE : {
-                /* this stuff *must* be here rather than in the "init"
-                 * routine because the CMS is not loaded into the
-                 * window object until the "set" routines are called.
-                 */
-                Cms cms = xv_get(bitmap_public, WIN_CMS);
-                XGCValues gcvalues;
-                Display *dpy =
-                    (Display *)xv_get(bitmap_public, XV_DISPLAY);
-                gcvalues.foreground =
-                    (unsigned long)xv_get(cms, CMS_FOREGROUND_PIXEL);
-                gcvalues.background =
-                    (unsigned long)xv_get(cms, CMS_BACKGROUND_PIXEL);
-                gcvalues.graphics_exposures = False;
-                bitmap_private->gc =
-                    XCreateGC(dpy, xv_get(bitmap_public, XV_XID),
-                        GCForeground|GCBackground|GCGraphicsExposures,
-                        &gcvalues);
-            }
-            default :
-                xv_check_bad_attr(BITMAP, attrs[0]);
-                break;
-        }
-    return XV_OK;
-}
-
-static Xv_opaque
-bitmap_get(bitmap_public, status, attr, args)
-Bitmap_public     *bitmap_public;
-int             *status;
-Attr_attribute  attr;
-Attr_avlist     args;
-{
-    Bitmap_private *bitmap_private = BITMAP_PRIVATE(bitmap_public);
-
-    switch ((int) attr) {
-        case BITMAP_PIXMAP :
-            return (Xv_opaque)bitmap_private->bitmap;
-        case BITMAP_FILE : /* can't get this attribute */
-        default :
-            *status = xv_check_bad_attr(BITMAP, attr);
-            return (Xv_opaque)XV_OK;
-    }
-}
-
-/* destroy method: free the pixmap and the GC before freeing object */
-static int
-bitmap_destroy(bitmap_public, status)
-Bitmap_public     *bitmap_public;
-Destroy_status   status;
-{
-    Bitmap_private *bitmap_private = BITMAP_PRIVATE(bitmap_public);
-
-    if (status == DESTROY_CLEANUP) {
-        if (bitmap_private->bitmap)
-            XFreePixmap(xv_get(bitmap_public, XV_DISPLAY),
-                bitmap_private->bitmap);
-        XFreeGC(xv_get(bitmap_public, XV_DISPLAY),
-            bitmap_private->gc);
-        free(bitmap_private);
-    }
-    return XV_OK;
-}
--- origsrc/xview-3.2p1.4/contrib/examples/extensions/Image.c	1993-06-29 06:13:32.000000000 +0100
+++ src/xview-3.2p1.4/contrib/examples/extensions/Image.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,244 +0,0 @@
-/*
- * Image.c -- An extension to the Server_image object to support
- * xv_find().  This is done by creating a list of all the image
- * objects of this type and attaching it to the owner (screen).
- * The "screen" is chosen because when xv_find() is called, you
- * need to find the object associated with the same "screen" as
- * the owner's screen, otherwise what we return may not render
- * correctly.
- */
-#include "image_impl.h"
-
-static int image_init(), image_destroy();
-static Xv_opaque image_get(), image_set(), image_find();
-static void image_repaint();
-
-Xv_pkg image_pkg = {
-    "Image",                    /* package name */
-    ATTR_PKG_IMAGE,             /* package ID */
-    sizeof(Image_public),       /* size of the public struct */
-    SERVER_IMAGE,               /* subclassed from the server image */
-    image_init,
-    image_set,
-    image_get,
-    image_destroy,
-    image_find
-};
-
-/* initialize the image object -- create (alloc) an instance of it and
- * connect the public and private parts.  Since this package supports
- * xv_find(), createa linked list and/or append the newly created
- * instance of this object to the end of the list.
- */
-static int
-image_init(owner, image_public, avlist)
-Xv_Screen       owner;
-Image_public   *image_public;
-Attr_avlist     avlist;            /* ignored here */
-{
-    Attr_attribute *attrs;
-    Image_private *image_private = xv_alloc(Image_private);
-    Image_private *list; /* linked list of image instances */
-    Xv_Screen screen = owner? owner : xv_default_screen;
-
-    if (!image_private || !screen)
-        return XV_ERROR;
-
-    /* link the public to the private and vice-versa */
-    image_public->private_data = (Xv_opaque)image_private;
-    image_private->public_self = (Xv_opaque)image_public;
-
-    for (attrs = avlist; *attrs; attrs = attr_next(attrs))
-        if (attrs[0] == SERVER_IMAGE_BITMAP_FILE)
-            image_private->filename =
-                strcpy(malloc(strlen(attrs[1])+1), attrs[1]);
-
-    image_private->next = (Image_private *)NULL;
-    image_private->screen = screen;
-
-    /* get the list of existing images from the screen */
-    if (list = (Image_private *)xv_get(screen,
-                    XV_KEY_DATA, ATTR_PKG_IMAGE)) {
-        /* follow list till the end */
-        while (list->next)
-            list = list->next;
-        /* assign new image object to end of list */
-        list->next = image_private;
-    } else {
-        /* no image objects on this screen -- create a new list */
-        xv_set(screen,
-            XV_KEY_DATA, ATTR_PKG_IMAGE, image_private,
-            NULL);
-    }
-    return XV_OK;
-}
-
-/* image_set() -- needed to track whether "filename" changes */
-static Xv_opaque
-image_set(image_public, avlist)
-Image_public   *image_public;
-Attr_avlist     avlist;
-{
-    Attr_attribute *attrs;
-    Image_private *image_private = IMAGE_PRIVATE(image_public);
-
-    /* loop thru attrs looking for anything that would invalidate
-     * the fact that the filename is set to a valid file.  If the
-     * programmer is assigning a new pixmap or data to this server
-     * image, the filename that was originally associated with the
-     * object is no longer valid.  Disable for later get/find calls.
-     */
-    if (image_private->filename)
-        for (attrs = avlist; *attrs; attrs = attr_next(attrs))
-            if (attrs[0] == SERVER_IMAGE_PIXMAP ||
-                attrs[0] == SERVER_IMAGE_BITS   ||
-                attrs[0] == SERVER_IMAGE_X_BITS) {
-                    free(image_private->filename);
-                    image_private->filename = NULL;
-            }
-
-    return (Xv_opaque)XV_OK;
-}
-
-/* image_get() -- Support xv_get() for SERVER_IMAGE_BITMAP_FILE
- * and XV_SCREEN.  Warning: because this package is subclassed
- * from the Server_image package, we must not attempt to return
- * values for attrs that the Server_image package supports.
- */
-static Xv_opaque
-image_get(image_public, status, attr, args)
-Image_public   *image_public;
-int            *status;
-Attr_attribute  attr;
-Attr_avlist     args;
-{
-    Image_private *image_private = IMAGE_PRIVATE(image_public);
-
-    switch ((int) attr) {
-        case SERVER_IMAGE_BITMAP_FILE :
-            return (Xv_opaque)image_private->filename;
-        case XV_SCREEN :
-            return (Xv_opaque)image_private->screen;
-        default :
-            *status = xv_check_bad_attr(IMAGE, attr);
-            return (Xv_opaque)XV_OK;
-    }
-}
-
-/* destroy method: free the object and remove from linked list */
-static int
-image_destroy(image_public, status)
-Image_public    *image_public;
-Destroy_status   status;
-{
-    Image_private *image_private = IMAGE_PRIVATE(image_public);
-    Image_private *list; /* linked list of image instances */
-    Xv_Screen screen = image_private->screen;
-
-    if (status == DESTROY_CLEANUP) {
-        /* get the list of existing images from the screen */
-        list = (Image_private *)xv_get(screen,
-                        XV_KEY_DATA, ATTR_PKG_IMAGE);
-        if ((Image)XV_PUBLIC(list) == (Image)image_public)
-            xv_set(screen,
-                XV_KEY_DATA, ATTR_PKG_IMAGE, list->next,
-                NULL);
-        for ( ; list->next; list = list->next)
-            if ((Image)XV_PUBLIC(list->next) == (Image)image_public) {
-                list->next = list->next->next;
-                break;
-            }
-        if (list->filename)
-            free(list->filename);
-        free(list);
-    }
-
-    return XV_OK;
-}
-
-/* image_find() -- find an existing image object that matches the
- * attribute-values specified here.  If none found, return NULL.
- * XView internals handle the XV_AUTO_CREATE case.  This function
- * supports finding images according to the following attributes:
- * XV_WIDTH, XV_HEIGHT, SERVER_IMAGE_DEPTH, SERVER_IMAGE_PIXMAP
- * and SERVER_IMAGE_BITMAP_FILE.  All others result in a NULL return.
- */
-static Xv_opaque
-image_find(owner, pkg, avlist)
-Xv_Screen       owner;
-Xv_pkg         *pkg;
-Attr_avlist     avlist;            /* ignored here */
-{
-    Image_private *list; /* linked list of image instances */
-    /* this is what the server image package does */
-    Xv_Screen screen = owner? owner : xv_default_screen;
-    Attr_attribute *attrs;
-    /* consider all the attrs we allow "find" to match on */
-    int     width = -1, height = -1, depth = -1;
-    Pixmap  pixmap = (Pixmap)NULL;
-    char   *filename = NULL;
-
-    /* get the list of existing images from the screen */
-    list = (Image_private *)xv_get(screen,
-                    XV_KEY_DATA, ATTR_PKG_IMAGE);
-
-    if (!list)
-        return NULL;
-
-    /* loop thru each attribute requested and save the value
-     * associated with it.  Later, we'll loop thru the existing
-     * objects looking for the object that has the same values.
-     */
-    for (attrs = avlist; *attrs; attrs = attr_next(attrs))
-        switch ((int)attrs[0]) {
-            case XV_WIDTH :
-                width = (int)attrs[1];
-                break;
-            case XV_HEIGHT :
-                height = (int)attrs[1];
-                break;
-            case SERVER_IMAGE_DEPTH :
-                depth = (int)attrs[1];
-                break;
-            case SERVER_IMAGE_PIXMAP :
-                pixmap = (Pixmap)attrs[1];
-                break;
-            case SERVER_IMAGE_BITMAP_FILE :
-                filename = (char *)attrs[1];
-                break;
-            case SERVER_IMAGE_BITS :
-            case SERVER_IMAGE_X_BITS :
-            case SERVER_IMAGE_COLORMAP :
-            case SERVER_IMAGE_CMS :
-            case SERVER_IMAGE_SAVE_PIXMAP :
-            default :
-                return NULL; /* you can't "find" for these attrs */
-        }
-    /* Now loop thru each object looking for those whose
-     * value that match those specified above.
-     */
-    for ( ; list; list = list->next) {
-        /* If it doesn't match, continue to the next object in
-         * the list.  Repeat for each requested attribute.
-         */
-        if (width > -1 &&
-            (width != (int)xv_get(XV_PUBLIC(list), XV_WIDTH)))
-            continue;
-        if (height > -1 &&
-            (height != (int)xv_get(XV_PUBLIC(list), XV_HEIGHT)))
-            continue;
-        if (depth > -1 && (depth != (int)xv_get(XV_PUBLIC(list),
-                                    SERVER_IMAGE_DEPTH)))
-            continue;
-        if (pixmap && (pixmap != (Pixmap)xv_get(XV_PUBLIC(list),
-                                    SERVER_IMAGE_PIXMAP)))
-            continue;
-        if (filename &&
-            (!list->filename || strcmp(filename, list->filename)))
-            continue;
-        /* all matches seemed to be successful, return this object */
-        return XV_PUBLIC(list);
-    }
-    /* nothing found */
-    return NULL;
-}
--- origsrc/xview-3.2p1.4/contrib/examples/extensions/Imakefile	2013-02-23 14:43:38.015625000 +0000
+++ src/xview-3.2p1.4/contrib/examples/extensions/Imakefile	2013-02-23 14:44:38.109375000 +0000
@@ -20,22 +20,22 @@ MAKEFILE_SIMPLE = Makefile.customer
 ALLFILES = $(MAKEFILE_SIMPLE) $(SRCS)
 
 
-BITMAP_CFILES	= Bitmap.c \
+BITMAP_CFILES	= bitmap1.c \
 		  bitmap.c
 
-BITMAP_OBJS	= Bitmap.o bitmap.o
+BITMAP_OBJS	= bitmap1.o bitmap.o
 BITMAP_HDRS	= bitmap.h bitmap_impl.h
 
-IMAGE_CFILES	= Image.c \
+IMAGE_CFILES	= image1.c \
 		  image.c
 
-IMAGE_OBJS	= Image.o image.o
+IMAGE_OBJS	= image1.o image.o
 IMAGE_HDRS	= image.h image_impl.h
 
-LOGO_CFILES	= Logo.c \
+LOGO_CFILES	= logo1.c \
 		  logo.c
 
-LOGO_OBJS	= Logo.o logo.o
+LOGO_OBJS	= logo1.o logo.o
 LOGO_HDRS	= logo.h logo_impl.h
 
 INSTALL_SRCS	= $(BITMAP_CFILES) $(BITMAP_HDRS) \
--- origsrc/xview-3.2p1.4/contrib/examples/extensions/Logo.c	1993-06-29 06:13:32.000000000 +0100
+++ src/xview-3.2p1.4/contrib/examples/extensions/Logo.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,178 +0,0 @@
-/*
- * Logo.c -- a XView object class that paints an X logo in a window.
- * This object is subclassed from the window object to take advantage
- * of the window it creates.  This object has no attributes, so the
- * set and get functions are virtually empty.  The only internal
- * fields used by this object are a GC and a Pixmap.  The GC is used
- * to paint the Pixmap into the window.  The window object has no GC
- * associated with it or we would have inherited it.  This will
- * probably go away in the next version of XView.
- */
-#include "logo_impl.h"
-#include <xview/notify.h>
-#include <xview/cms.h>
-#include <X11/bitmaps/xlogo32>
-
-/* declare the "methods" used by the logo class. */
-static int logo_init(), logo_destroy();
-static Xv_opaque logo_set(), logo_get();
-static void logo_repaint();
-
-Xv_pkg logo_pkg = {
-    "Logo",                     /* package name */
-    ATTR_PKG_UNUSED_FIRST,      /* package ID */
-    sizeof(Logo_public),        /* size of the public struct */
-    WINDOW,                     /* subclassed from the window package */
-    logo_init,
-    logo_set,
-    logo_get,
-    logo_destroy,
-    NULL                        /* disable the use of xv_find() */
-};
-
-/* the only thing this object does is paint an X into its own window.
- * This is the event handling routine that is used to check for
- * Expose or Configure event requests.  the configure event clears
- * the window and the "expose" event causes a repaint of the X image.
- * The GC has it's foreground and background colros set from the
- * CMS of the window from which this logo object is subclassed.
- */
-static void
-logo_redraw(logo_public, event)
-Logo_public     *logo_public;
-Event           *event;
-{
-    Logo_private *logo_private = LOGO_PRIVATE(logo_public);
-    XEvent *xevent = event_xevent(event);
-
-    if (xevent->xany.type == Expose && xevent->xexpose.count == 0) {
-        Display *dpy = (Display *)xv_get(logo_public, XV_DISPLAY);
-        Window window = (Window)xv_get(logo_public, XV_XID);
-        int width = (int)xv_get(logo_public, XV_WIDTH);
-        int height = (int)xv_get(logo_public, XV_HEIGHT);
-        int x = (width - xlogo32_width)/2;
-        int y = (height - xlogo32_height)/2;
-
-        XCopyPlane(dpy, logo_private->bitmap, window, logo_private->gc,
-            0, 0, xlogo32_width, xlogo32_height, x, y, 1L);
-    } else if (xevent->xany.type == ConfigureNotify)
-        XClearArea(xv_get(logo_public, XV_DISPLAY),
-            xv_get(logo_public, XV_XID), 0, 0,
-            xevent->xconfigure.width, xevent->xconfigure.height, True);
-}
-
-/* initialize the logo object -- create (alloc) an instance of it.
- * There are two parts to an object class: a public part and a private
- * part.  Each contains a pointer to the other, so link the two
- * together and initialize the remaining fields of the logo data
- * structure.  This includes creating the Xlogo pixmap.  However,
- * we do no initialize the logo's GC because it is dependent on its
- * window's cms and that isn't assigned to the window till the "set"
- * method.  See logo_set() below.
- */
-static int
-logo_init(owner, logo_public, avlist)
-Xv_opaque       owner;
-Logo_public     *logo_public;
-Attr_avlist     avlist; /* ignored here */
-{
-    Logo_private *logo_private = xv_alloc(Logo_private);
-    Display *dpy;
-    Window win;
-
-    if (!logo_private)
-        return XV_ERROR;
-
-    dpy = (Display *)xv_get(owner, XV_DISPLAY);
-    win = (Window)xv_get(logo_public, XV_XID);
-
-    /* link the public to the private and vice-versa */
-    logo_public->private_data = (Xv_opaque)logo_private;
-    logo_private->public_self = (Xv_opaque)logo_public;
-
-    /* create the 1-bit deep pixmap of the X logo */
-    if ((logo_private->bitmap = XCreatePixmapFromBitmapData(dpy, win,
-        xlogo32_bits, xlogo32_width, xlogo32_height,
-        1, 0, 1)) == NULL) {
-        free(logo_private);
-        return XV_ERROR;
-    }
-    /* set up event handlers to get resize and repaint events */
-    xv_set(logo_public,
-        WIN_NOTIFY_SAFE_EVENT_PROC,      logo_redraw,
-        WIN_NOTIFY_IMMEDIATE_EVENT_PROC, logo_redraw,
-        NULL);
-
-    return XV_OK;
-}
-
-/* logo_set() -- the function called to set attributes in a logo
- * object.  This function is called when a logo is created after
- * the init routine as well as when the programmer calls xv_set.
- */
-static Xv_opaque
-logo_set(logo_public, avlist)
-Logo_public *logo_public;
-Attr_avlist avlist;
-{
-    Logo_private *logo_private = LOGO_PRIVATE(logo_public);
-    Attr_attribute *attrs;
-
-    for (attrs = avlist; *attrs; attrs = attr_next(attrs))
-        switch ((int) attrs[0]) {
-            case XV_END_CREATE : {
-                /* this stuff *must* be here rather than in the "init"
-                 * routine because the CMS is not loaded into the
-                 * window object until the "set" routines are called.
-                 */
-                Cms cms = xv_get(logo_public, WIN_CMS);
-                XGCValues gcvalues;
-                Display *dpy =
-                    (Display *)xv_get(logo_public, XV_DISPLAY);
-                gcvalues.foreground =
-                    (unsigned long)xv_get(cms, CMS_FOREGROUND_PIXEL);
-                gcvalues.background =
-                    (unsigned long)xv_get(cms, CMS_BACKGROUND_PIXEL);
-                gcvalues.graphics_exposures = False;
-                logo_private->gc = XCreateGC(dpy,
-                    xv_get(logo_public, XV_XID),
-                    GCForeground|GCBackground|GCGraphicsExposures,
-                    &gcvalues);
-            }
-            default :
-                xv_check_bad_attr(LOGO, attrs[0]);
-                break;
-        }
-
-    return XV_OK;
-}
-
-/* logo_get() -- There are no logo attributes to get, so just return */
-static Xv_opaque
-logo_get(logo_public, status, attr, args)
-Logo_public     *logo_public;
-int             *status;
-Attr_attribute  attr;
-Attr_avlist     args;
-{
-    *status = xv_check_bad_attr(LOGO, attr);
-    return (Xv_opaque)XV_OK;
-}
-
-/* destroy method: free the pixmap and the GC before freeing the object */
-static int
-logo_destroy(logo_public, status)
-Logo_public     *logo_public;
-Destroy_status   status;
-{
-    Logo_private *logo_private = LOGO_PRIVATE(logo_public);
-
-    if (status == DESTROY_CLEANUP) {
-        XFreePixmap(xv_get(logo_public, XV_DISPLAY),
-            logo_private->bitmap);
-        XFreeGC(xv_get(logo_public, XV_DISPLAY), logo_private->gc);
-        free(logo_private);
-    }
-
-    return XV_OK;
-}
--- origsrc/xview-3.2p1.4/contrib/examples/extensions/Makefile.customer	1993-06-29 06:13:33.000000000 +0100
+++ src/xview-3.2p1.4/contrib/examples/extensions/Makefile.customer	2013-02-23 14:44:38.109375000 +0000
@@ -29,17 +29,17 @@ HDRS		= bitmap.h \
 		  logo.h \
 		  logo_impl.h
 
-BITMAP_CFILES	= Bitmap.c \
+BITMAP_CFILES	= bitmap1.c \
 		  bitmap.c
 
 BITMAP_OBJS	= $(BITMAP_CFILES:.c=.o)
 
-IMAGE_CFILES	= Image.c \
+IMAGE_CFILES	= image1.c \
 		  image.c
 
 IMAGE_OBJS	= $(IMAGE_CFILES:.c=.o)
 
-LOGO_CFILES	= Logo.c \
+LOGO_CFILES	= logo1.c \
 		  logo.c
 
 LOGO_OBJS	= $(LOGO_CFILES:.c=.o)
@@ -64,9 +64,9 @@ image: $(IMAGE_OBJS)
 logo.o: logo.h
 bitmap.o: bitmap.h
 image.o: image.h
-Logo.o: logo_impl.h logo.h
-Bitmap.o: bitmap_impl.h bitmap.h
-Image.o: image_impl.h image.h
+logo1.o: logo_impl.h logo.h
+bitmap1.o: bitmap_impl.h bitmap.h
+image1.o: image_impl.h image.h
  
 clean:
 	rm -f *.o core a.out *.BAK make.log $(PROGRAMS)
--- origsrc/xview-3.2p1.4/contrib/examples/extensions/bitmap1.c	1970-01-01 01:00:00.000000000 +0100
+++ src/xview-3.2p1.4/contrib/examples/extensions/bitmap1.c	2013-02-23 14:44:38.109375000 +0000
@@ -0,0 +1,189 @@
+/*
+ * Bitmap.c -- an XView object class that displays an arbitrary
+ * pixmap.  This is similar to the Logo object, but the programmer
+ * may specify the bitmap to use via the BITMAP_FILE attribute.
+ */
+#include "bitmap_impl.h"
+#include <xview/notify.h>
+#include <xview/cms.h>
+#include <X11/Xutil.h>
+
+/* declare the "methods" used by the bitmap class. */
+static int bitmap_init(), bitmap_destroy();
+static Xv_opaque bitmap_set(), bitmap_get();
+static void bitmap_repaint();
+
+Xv_pkg bitmap_pkg = {
+    "Bitmap2",               /* package name */
+    ATTR_PKG_BITMAP,         /* package ID */
+    sizeof(Bitmap_public),   /* size of the public struct */
+    WINDOW,                  /* subclassed from the window package */
+    bitmap_init,
+    bitmap_set,
+    bitmap_get,
+    bitmap_destroy,
+    NULL                     /* disable the use of xv_find() */
+};
+
+static void
+bitmap_redraw(bitmap_public, event)
+Bitmap_public     *bitmap_public;
+Event           *event;
+{
+    Bitmap_private *bitmap_private = BITMAP_PRIVATE(bitmap_public);
+    XEvent *xevent = event_xevent(event);
+
+    if (bitmap_private->bitmap &&
+        xevent->xany.type == Expose && xevent->xexpose.count == 0) {
+        Display *dpy = (Display *)xv_get(bitmap_public, XV_DISPLAY);
+        Window window = (Window)xv_get(bitmap_public, XV_XID);
+        int width = (int)xv_get(bitmap_public, XV_WIDTH);
+        int height = (int)xv_get(bitmap_public, XV_HEIGHT);
+        int x = (width - bitmap_private->width)/2;
+        int y = (height - bitmap_private->height)/2;
+
+        XCopyPlane(dpy, bitmap_private->bitmap, window,
+            bitmap_private->gc, 0, 0, bitmap_private->width,
+            bitmap_private->height, x, y, 1L);
+    } else if (xevent->xany.type == ConfigureNotify)
+        XClearArea(xv_get(bitmap_public, XV_DISPLAY),
+            xv_get(bitmap_public, XV_XID), 0, 0,
+            xevent->xconfigure.width, xevent->xconfigure.height,
+            True);
+}
+
+/* initialize the bitmap object by creating (alloc) an instance
+ * of it.  There are two parts to an object class: a public part
+ * and a private part.  Each contains a pointer to the other, so
+ * link the two together and initialize the remaining fields of
+ * the bitmap data structure.  Do no initialize the bitmap's GC
+ * because it is dependent on its window's cms and that isn't
+ * assigned to the window till the "set" method.  Also, wait till
+ * till the "set" method to initialize the bitmap file specified.
+ */
+static int
+bitmap_init(owner, bitmap_public, avlist)
+Xv_opaque       owner;
+Bitmap_public     *bitmap_public;
+Attr_avlist     avlist; /* ignored here */
+{
+    Bitmap_private *bitmap_private = xv_alloc(Bitmap_private);
+
+    if (!bitmap_private)
+        return XV_ERROR;
+
+    /* link the public to the private and vice-versa */
+    bitmap_public->private_data = (Xv_opaque)bitmap_private;
+    bitmap_private->public_self = (Xv_opaque)bitmap_public;
+
+    /* set up event handlers to get resize and repaint events */
+    xv_set(bitmap_public,
+        WIN_NOTIFY_SAFE_EVENT_PROC,      bitmap_redraw,
+        WIN_NOTIFY_IMMEDIATE_EVENT_PROC, bitmap_redraw,
+        NULL);
+
+    return XV_OK;
+}
+
+/* bitmap_set() -- the function called to set attributes in a bitmap
+ * object.  This function is called when a bitmap is created after
+ * the init routine as well as when the programmer calls xv_set.
+ */
+static Xv_opaque
+bitmap_set(bitmap_public, avlist)
+Bitmap_public *bitmap_public;
+Attr_avlist avlist;
+{
+    Bitmap_private *bitmap_private = BITMAP_PRIVATE(bitmap_public);
+    Attr_attribute *attrs;
+
+    for (attrs = avlist; *attrs; attrs = attr_next(attrs))
+        switch ((int) attrs[0]) {
+            case BITMAP_FILE : {
+                int val, x, y;
+                Display *dpy =
+                    (Display *)xv_get(bitmap_public, XV_DISPLAY);
+                Window window =
+                    (Window)xv_get(bitmap_public, XV_XID);
+                Pixmap old = bitmap_private->bitmap;
+                if (XReadBitmapFile(dpy, window, attrs[1],
+                    &bitmap_private->width, &bitmap_private->height,
+                    &bitmap_private->bitmap, &x, &y) != BitmapSuccess)
+                {
+                    xv_error(bitmap_public,
+                        ERROR_STRING, "Unable to load bitmap file",
+                        ERROR_PKG,    BITMAP,
+                        NULL);
+                    bitmap_private->bitmap = old;
+                }
+                break;
+            }
+            case BITMAP_PIXMAP :
+                xv_error(bitmap_public,
+                    ERROR_CANNOT_SET, attrs[0],
+                    ERROR_PKG,        BITMAP,
+                    NULL);
+                break;
+            case XV_END_CREATE : {
+                /* this stuff *must* be here rather than in the "init"
+                 * routine because the CMS is not loaded into the
+                 * window object until the "set" routines are called.
+                 */
+                Cms cms = xv_get(bitmap_public, WIN_CMS);
+                XGCValues gcvalues;
+                Display *dpy =
+                    (Display *)xv_get(bitmap_public, XV_DISPLAY);
+                gcvalues.foreground =
+                    (unsigned long)xv_get(cms, CMS_FOREGROUND_PIXEL);
+                gcvalues.background =
+                    (unsigned long)xv_get(cms, CMS_BACKGROUND_PIXEL);
+                gcvalues.graphics_exposures = False;
+                bitmap_private->gc =
+                    XCreateGC(dpy, xv_get(bitmap_public, XV_XID),
+                        GCForeground|GCBackground|GCGraphicsExposures,
+                        &gcvalues);
+            }
+            default :
+                xv_check_bad_attr(BITMAP, attrs[0]);
+                break;
+        }
+    return XV_OK;
+}
+
+static Xv_opaque
+bitmap_get(bitmap_public, status, attr, args)
+Bitmap_public     *bitmap_public;
+int             *status;
+Attr_attribute  attr;
+Attr_avlist     args;
+{
+    Bitmap_private *bitmap_private = BITMAP_PRIVATE(bitmap_public);
+
+    switch ((int) attr) {
+        case BITMAP_PIXMAP :
+            return (Xv_opaque)bitmap_private->bitmap;
+        case BITMAP_FILE : /* can't get this attribute */
+        default :
+            *status = xv_check_bad_attr(BITMAP, attr);
+            return (Xv_opaque)XV_OK;
+    }
+}
+
+/* destroy method: free the pixmap and the GC before freeing object */
+static int
+bitmap_destroy(bitmap_public, status)
+Bitmap_public     *bitmap_public;
+Destroy_status   status;
+{
+    Bitmap_private *bitmap_private = BITMAP_PRIVATE(bitmap_public);
+
+    if (status == DESTROY_CLEANUP) {
+        if (bitmap_private->bitmap)
+            XFreePixmap(xv_get(bitmap_public, XV_DISPLAY),
+                bitmap_private->bitmap);
+        XFreeGC(xv_get(bitmap_public, XV_DISPLAY),
+            bitmap_private->gc);
+        free(bitmap_private);
+    }
+    return XV_OK;
+}
--- origsrc/xview-3.2p1.4/contrib/examples/extensions/image1.c	1970-01-01 01:00:00.000000000 +0100
+++ src/xview-3.2p1.4/contrib/examples/extensions/image1.c	2013-02-23 14:44:38.109375000 +0000
@@ -0,0 +1,244 @@
+/*
+ * Image.c -- An extension to the Server_image object to support
+ * xv_find().  This is done by creating a list of all the image
+ * objects of this type and attaching it to the owner (screen).
+ * The "screen" is chosen because when xv_find() is called, you
+ * need to find the object associated with the same "screen" as
+ * the owner's screen, otherwise what we return may not render
+ * correctly.
+ */
+#include "image_impl.h"
+
+static int image_init(), image_destroy();
+static Xv_opaque image_get(), image_set(), image_find();
+static void image_repaint();
+
+Xv_pkg image_pkg = {
+    "Image",                    /* package name */
+    ATTR_PKG_IMAGE,             /* package ID */
+    sizeof(Image_public),       /* size of the public struct */
+    SERVER_IMAGE,               /* subclassed from the server image */
+    image_init,
+    image_set,
+    image_get,
+    image_destroy,
+    image_find
+};
+
+/* initialize the image object -- create (alloc) an instance of it and
+ * connect the public and private parts.  Since this package supports
+ * xv_find(), createa linked list and/or append the newly created
+ * instance of this object to the end of the list.
+ */
+static int
+image_init(owner, image_public, avlist)
+Xv_Screen       owner;
+Image_public   *image_public;
+Attr_avlist     avlist;            /* ignored here */
+{
+    Attr_attribute *attrs;
+    Image_private *image_private = xv_alloc(Image_private);
+    Image_private *list; /* linked list of image instances */
+    Xv_Screen screen = owner? owner : xv_default_screen;
+
+    if (!image_private || !screen)
+        return XV_ERROR;
+
+    /* link the public to the private and vice-versa */
+    image_public->private_data = (Xv_opaque)image_private;
+    image_private->public_self = (Xv_opaque)image_public;
+
+    for (attrs = avlist; *attrs; attrs = attr_next(attrs))
+        if (attrs[0] == SERVER_IMAGE_BITMAP_FILE)
+            image_private->filename =
+                strcpy(malloc(strlen(attrs[1])+1), attrs[1]);
+
+    image_private->next = (Image_private *)NULL;
+    image_private->screen = screen;
+
+    /* get the list of existing images from the screen */
+    if (list = (Image_private *)xv_get(screen,
+                    XV_KEY_DATA, ATTR_PKG_IMAGE)) {
+        /* follow list till the end */
+        while (list->next)
+            list = list->next;
+        /* assign new image object to end of list */
+        list->next = image_private;
+    } else {
+        /* no image objects on this screen -- create a new list */
+        xv_set(screen,
+            XV_KEY_DATA, ATTR_PKG_IMAGE, image_private,
+            NULL);
+    }
+    return XV_OK;
+}
+
+/* image_set() -- needed to track whether "filename" changes */
+static Xv_opaque
+image_set(image_public, avlist)
+Image_public   *image_public;
+Attr_avlist     avlist;
+{
+    Attr_attribute *attrs;
+    Image_private *image_private = IMAGE_PRIVATE(image_public);
+
+    /* loop thru attrs looking for anything that would invalidate
+     * the fact that the filename is set to a valid file.  If the
+     * programmer is assigning a new pixmap or data to this server
+     * image, the filename that was originally associated with the
+     * object is no longer valid.  Disable for later get/find calls.
+     */
+    if (image_private->filename)
+        for (attrs = avlist; *attrs; attrs = attr_next(attrs))
+            if (attrs[0] == SERVER_IMAGE_PIXMAP ||
+                attrs[0] == SERVER_IMAGE_BITS   ||
+                attrs[0] == SERVER_IMAGE_X_BITS) {
+                    free(image_private->filename);
+                    image_private->filename = NULL;
+            }
+
+    return (Xv_opaque)XV_OK;
+}
+
+/* image_get() -- Support xv_get() for SERVER_IMAGE_BITMAP_FILE
+ * and XV_SCREEN.  Warning: because this package is subclassed
+ * from the Server_image package, we must not attempt to return
+ * values for attrs that the Server_image package supports.
+ */
+static Xv_opaque
+image_get(image_public, status, attr, args)
+Image_public   *image_public;
+int            *status;
+Attr_attribute  attr;
+Attr_avlist     args;
+{
+    Image_private *image_private = IMAGE_PRIVATE(image_public);
+
+    switch ((int) attr) {
+        case SERVER_IMAGE_BITMAP_FILE :
+            return (Xv_opaque)image_private->filename;
+        case XV_SCREEN :
+            return (Xv_opaque)image_private->screen;
+        default :
+            *status = xv_check_bad_attr(IMAGE, attr);
+            return (Xv_opaque)XV_OK;
+    }
+}
+
+/* destroy method: free the object and remove from linked list */
+static int
+image_destroy(image_public, status)
+Image_public    *image_public;
+Destroy_status   status;
+{
+    Image_private *image_private = IMAGE_PRIVATE(image_public);
+    Image_private *list; /* linked list of image instances */
+    Xv_Screen screen = image_private->screen;
+
+    if (status == DESTROY_CLEANUP) {
+        /* get the list of existing images from the screen */
+        list = (Image_private *)xv_get(screen,
+                        XV_KEY_DATA, ATTR_PKG_IMAGE);
+        if ((Image)XV_PUBLIC(list) == (Image)image_public)
+            xv_set(screen,
+                XV_KEY_DATA, ATTR_PKG_IMAGE, list->next,
+                NULL);
+        for ( ; list->next; list = list->next)
+            if ((Image)XV_PUBLIC(list->next) == (Image)image_public) {
+                list->next = list->next->next;
+                break;
+            }
+        if (list->filename)
+            free(list->filename);
+        free(list);
+    }
+
+    return XV_OK;
+}
+
+/* image_find() -- find an existing image object that matches the
+ * attribute-values specified here.  If none found, return NULL.
+ * XView internals handle the XV_AUTO_CREATE case.  This function
+ * supports finding images according to the following attributes:
+ * XV_WIDTH, XV_HEIGHT, SERVER_IMAGE_DEPTH, SERVER_IMAGE_PIXMAP
+ * and SERVER_IMAGE_BITMAP_FILE.  All others result in a NULL return.
+ */
+static Xv_opaque
+image_find(owner, pkg, avlist)
+Xv_Screen       owner;
+Xv_pkg         *pkg;
+Attr_avlist     avlist;            /* ignored here */
+{
+    Image_private *list; /* linked list of image instances */
+    /* this is what the server image package does */
+    Xv_Screen screen = owner? owner : xv_default_screen;
+    Attr_attribute *attrs;
+    /* consider all the attrs we allow "find" to match on */
+    int     width = -1, height = -1, depth = -1;
+    Pixmap  pixmap = (Pixmap)NULL;
+    char   *filename = NULL;
+
+    /* get the list of existing images from the screen */
+    list = (Image_private *)xv_get(screen,
+                    XV_KEY_DATA, ATTR_PKG_IMAGE);
+
+    if (!list)
+        return NULL;
+
+    /* loop thru each attribute requested and save the value
+     * associated with it.  Later, we'll loop thru the existing
+     * objects looking for the object that has the same values.
+     */
+    for (attrs = avlist; *attrs; attrs = attr_next(attrs))
+        switch ((int)attrs[0]) {
+            case XV_WIDTH :
+                width = (int)attrs[1];
+                break;
+            case XV_HEIGHT :
+                height = (int)attrs[1];
+                break;
+            case SERVER_IMAGE_DEPTH :
+                depth = (int)attrs[1];
+                break;
+            case SERVER_IMAGE_PIXMAP :
+                pixmap = (Pixmap)attrs[1];
+                break;
+            case SERVER_IMAGE_BITMAP_FILE :
+                filename = (char *)attrs[1];
+                break;
+            case SERVER_IMAGE_BITS :
+            case SERVER_IMAGE_X_BITS :
+            case SERVER_IMAGE_COLORMAP :
+            case SERVER_IMAGE_CMS :
+            case SERVER_IMAGE_SAVE_PIXMAP :
+            default :
+                return NULL; /* you can't "find" for these attrs */
+        }
+    /* Now loop thru each object looking for those whose
+     * value that match those specified above.
+     */
+    for ( ; list; list = list->next) {
+        /* If it doesn't match, continue to the next object in
+         * the list.  Repeat for each requested attribute.
+         */
+        if (width > -1 &&
+            (width != (int)xv_get(XV_PUBLIC(list), XV_WIDTH)))
+            continue;
+        if (height > -1 &&
+            (height != (int)xv_get(XV_PUBLIC(list), XV_HEIGHT)))
+            continue;
+        if (depth > -1 && (depth != (int)xv_get(XV_PUBLIC(list),
+                                    SERVER_IMAGE_DEPTH)))
+            continue;
+        if (pixmap && (pixmap != (Pixmap)xv_get(XV_PUBLIC(list),
+                                    SERVER_IMAGE_PIXMAP)))
+            continue;
+        if (filename &&
+            (!list->filename || strcmp(filename, list->filename)))
+            continue;
+        /* all matches seemed to be successful, return this object */
+        return XV_PUBLIC(list);
+    }
+    /* nothing found */
+    return NULL;
+}
--- origsrc/xview-3.2p1.4/contrib/examples/extensions/logo1.c	1970-01-01 01:00:00.000000000 +0100
+++ src/xview-3.2p1.4/contrib/examples/extensions/logo1.c	2013-02-23 14:44:38.187500000 +0000
@@ -0,0 +1,178 @@
+/*
+ * Logo.c -- a XView object class that paints an X logo in a window.
+ * This object is subclassed from the window object to take advantage
+ * of the window it creates.  This object has no attributes, so the
+ * set and get functions are virtually empty.  The only internal
+ * fields used by this object are a GC and a Pixmap.  The GC is used
+ * to paint the Pixmap into the window.  The window object has no GC
+ * associated with it or we would have inherited it.  This will
+ * probably go away in the next version of XView.
+ */
+#include "logo_impl.h"
+#include <xview/notify.h>
+#include <xview/cms.h>
+#include <X11/bitmaps/xlogo32>
+
+/* declare the "methods" used by the logo class. */
+static int logo_init(), logo_destroy();
+static Xv_opaque logo_set(), logo_get();
+static void logo_repaint();
+
+Xv_pkg logo_pkg = {
+    "Logo",                     /* package name */
+    ATTR_PKG_UNUSED_FIRST,      /* package ID */
+    sizeof(Logo_public),        /* size of the public struct */
+    WINDOW,                     /* subclassed from the window package */
+    logo_init,
+    logo_set,
+    logo_get,
+    logo_destroy,
+    NULL                        /* disable the use of xv_find() */
+};
+
+/* the only thing this object does is paint an X into its own window.
+ * This is the event handling routine that is used to check for
+ * Expose or Configure event requests.  the configure event clears
+ * the window and the "expose" event causes a repaint of the X image.
+ * The GC has it's foreground and background colros set from the
+ * CMS of the window from which this logo object is subclassed.
+ */
+static void
+logo_redraw(logo_public, event)
+Logo_public     *logo_public;
+Event           *event;
+{
+    Logo_private *logo_private = LOGO_PRIVATE(logo_public);
+    XEvent *xevent = event_xevent(event);
+
+    if (xevent->xany.type == Expose && xevent->xexpose.count == 0) {
+        Display *dpy = (Display *)xv_get(logo_public, XV_DISPLAY);
+        Window window = (Window)xv_get(logo_public, XV_XID);
+        int width = (int)xv_get(logo_public, XV_WIDTH);
+        int height = (int)xv_get(logo_public, XV_HEIGHT);
+        int x = (width - xlogo32_width)/2;
+        int y = (height - xlogo32_height)/2;
+
+        XCopyPlane(dpy, logo_private->bitmap, window, logo_private->gc,
+            0, 0, xlogo32_width, xlogo32_height, x, y, 1L);
+    } else if (xevent->xany.type == ConfigureNotify)
+        XClearArea(xv_get(logo_public, XV_DISPLAY),
+            xv_get(logo_public, XV_XID), 0, 0,
+            xevent->xconfigure.width, xevent->xconfigure.height, True);
+}
+
+/* initialize the logo object -- create (alloc) an instance of it.
+ * There are two parts to an object class: a public part and a private
+ * part.  Each contains a pointer to the other, so link the two
+ * together and initialize the remaining fields of the logo data
+ * structure.  This includes creating the Xlogo pixmap.  However,
+ * we do no initialize the logo's GC because it is dependent on its
+ * window's cms and that isn't assigned to the window till the "set"
+ * method.  See logo_set() below.
+ */
+static int
+logo_init(owner, logo_public, avlist)
+Xv_opaque       owner;
+Logo_public     *logo_public;
+Attr_avlist     avlist; /* ignored here */
+{
+    Logo_private *logo_private = xv_alloc(Logo_private);
+    Display *dpy;
+    Window win;
+
+    if (!logo_private)
+        return XV_ERROR;
+
+    dpy = (Display *)xv_get(owner, XV_DISPLAY);
+    win = (Window)xv_get(logo_public, XV_XID);
+
+    /* link the public to the private and vice-versa */
+    logo_public->private_data = (Xv_opaque)logo_private;
+    logo_private->public_self = (Xv_opaque)logo_public;
+
+    /* create the 1-bit deep pixmap of the X logo */
+    if ((logo_private->bitmap = XCreatePixmapFromBitmapData(dpy, win,
+        xlogo32_bits, xlogo32_width, xlogo32_height,
+        1, 0, 1)) == NULL) {
+        free(logo_private);
+        return XV_ERROR;
+    }
+    /* set up event handlers to get resize and repaint events */
+    xv_set(logo_public,
+        WIN_NOTIFY_SAFE_EVENT_PROC,      logo_redraw,
+        WIN_NOTIFY_IMMEDIATE_EVENT_PROC, logo_redraw,
+        NULL);
+
+    return XV_OK;
+}
+
+/* logo_set() -- the function called to set attributes in a logo
+ * object.  This function is called when a logo is created after
+ * the init routine as well as when the programmer calls xv_set.
+ */
+static Xv_opaque
+logo_set(logo_public, avlist)
+Logo_public *logo_public;
+Attr_avlist avlist;
+{
+    Logo_private *logo_private = LOGO_PRIVATE(logo_public);
+    Attr_attribute *attrs;
+
+    for (attrs = avlist; *attrs; attrs = attr_next(attrs))
+        switch ((int) attrs[0]) {
+            case XV_END_CREATE : {
+                /* this stuff *must* be here rather than in the "init"
+                 * routine because the CMS is not loaded into the
+                 * window object until the "set" routines are called.
+                 */
+                Cms cms = xv_get(logo_public, WIN_CMS);
+                XGCValues gcvalues;
+                Display *dpy =
+                    (Display *)xv_get(logo_public, XV_DISPLAY);
+                gcvalues.foreground =
+                    (unsigned long)xv_get(cms, CMS_FOREGROUND_PIXEL);
+                gcvalues.background =
+                    (unsigned long)xv_get(cms, CMS_BACKGROUND_PIXEL);
+                gcvalues.graphics_exposures = False;
+                logo_private->gc = XCreateGC(dpy,
+                    xv_get(logo_public, XV_XID),
+                    GCForeground|GCBackground|GCGraphicsExposures,
+                    &gcvalues);
+            }
+            default :
+                xv_check_bad_attr(LOGO, attrs[0]);
+                break;
+        }
+
+    return XV_OK;
+}
+
+/* logo_get() -- There are no logo attributes to get, so just return */
+static Xv_opaque
+logo_get(logo_public, status, attr, args)
+Logo_public     *logo_public;
+int             *status;
+Attr_attribute  attr;
+Attr_avlist     args;
+{
+    *status = xv_check_bad_attr(LOGO, attr);
+    return (Xv_opaque)XV_OK;
+}
+
+/* destroy method: free the pixmap and the GC before freeing the object */
+static int
+logo_destroy(logo_public, status)
+Logo_public     *logo_public;
+Destroy_status   status;
+{
+    Logo_private *logo_private = LOGO_PRIVATE(logo_public);
+
+    if (status == DESTROY_CLEANUP) {
+        XFreePixmap(xv_get(logo_public, XV_DISPLAY),
+            logo_private->bitmap);
+        XFreeGC(xv_get(logo_public, XV_DISPLAY), logo_private->gc);
+        free(logo_private);
+    }
+
+    return XV_OK;
+}
--- origsrc/xview-3.2p1.4/lib/libolgx/Imakefile	2013-02-23 14:43:43.312500000 +0000
+++ src/xview-3.2p1.4/lib/libolgx/Imakefile	2013-02-23 14:44:38.187500000 +0000
@@ -46,6 +46,6 @@ ALLFILES = $(SRCS) $(HEADERS) \
 
 #include <XView.lib>
 
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 XVIEW_DEPLIBS = $(LDPRELIBS) $(XLIB) -lc
 #endif
--- origsrc/xview-3.2p1.4/lib/libxview/Imakefile	2013-02-23 14:43:38.265625000 +0000
+++ src/xview-3.2p1.4/lib/libxview/Imakefile	2013-02-23 14:44:38.187500000 +0000
@@ -36,6 +36,6 @@ MakeLintLibSubdirs($(SUBDIRS))
 
 #include <XView.lib>
 
-#ifdef __linux__
+#if defined(__linux__) || defined(__CYGWIN__)
 XVIEW_DEPLIBS = $(LDPRELIBS) $(XLIB) -L../../libolgx -lolgx -lutil -lc
 #endif
--- origsrc/xview-3.2p1.4/lib/libxview/base/base.h	2013-02-23 14:43:40.625000000 +0000
+++ src/xview-3.2p1.4/lib/libxview/base/base.h	2013-02-23 14:44:38.187500000 +0000
@@ -53,7 +53,7 @@
  * the macro SUNOS41. This has to be fixed later to accomodate non-SUNOS41 and
  * non-SVR4 systems.
  */
-#if !defined(SUNOS41) && !defined(__linux__)
+#if !defined(SUNOS41) && !defined(__linux__) && !defined(__CYGWIN__)
 #define XV_OS_SVR4
 #define XV_USE_TTCOMPAT
 #define SYSV_WAIT 
@@ -64,6 +64,11 @@
 #undef XV_USE_TTCOMPAT
 #define SYSV_UCONTEXT 
 #define XV_USE_XVFCNTL 
+#elif defined(__CYGWIN__)
+#define XV_OS_SVR4
+#undef XV_USE_TTCOMPAT
+#undef SYSV_UCONTEXT 
+#define XV_USE_XVFCNTL
 #endif
  
 /*
--- origsrc/xview-3.2p1.4/lib/libxview/base/xv_error.c	2013-02-23 14:43:40.765625000 +0000
+++ src/xview-3.2p1.4/lib/libxview/base/xv_error.c	2013-02-23 14:44:38.265625000 +0000
@@ -16,7 +16,7 @@ static char     sccsid[] = "@(#)xv_error
 #include <xview_private/i18n_impl.h>
 #include <xview_private/portable.h>
 
-#if defined(__linux__) && defined(__GLIBC__)
+#if (defined(__linux__) && defined(__GLIBC__)) || defined(__CYGWIN__)
 /* martin.buck@bigfoot.com */
 #include <errno.h>
 #else
@@ -26,7 +26,7 @@ extern char    *sys_errlist[];
 extern int      errno;
 #endif
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 /* Global already defined in xv_init.c */
 Xv_private_data char *xv_app_name;
 #else
--- origsrc/xview-3.2p1.4/lib/libxview/dnd/site.c	2013-02-23 14:43:39.109375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/dnd/site.c	2013-02-23 14:44:38.265625000 +0000
@@ -241,7 +241,7 @@ DndDropAreaOps(site, mode, area)
 	      return(XV_ERROR);
 
 	  rect = xv_alloc(Rect);
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
           /* This will probably not work right, but it compiles. */
           /* (rectNode->rect) is of the wrong type. */
           memmove(rect, &(rectNode->rect),  sizeof(Rect));
--- origsrc/xview-3.2p1.4/lib/libxview/file_chooser/file_list.c	2013-02-23 14:43:41.609375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/file_chooser/file_list.c	2013-02-23 14:44:38.265625000 +0000
@@ -1147,7 +1147,7 @@ flist_update_list( private, rows, num_ro
 
 /****************************************************************************/
 
-#ifndef __linux__
+#if !defined __linux__ && !defined __CYGWIN__
 /*
  * Front end to regexp(3).
  *
@@ -1176,7 +1176,7 @@ flist_update_list( private, rows, num_ro
  * ifdef'd for SVR4 because it causes the 4.x MIT build to fail, not just print
  * warnings.
  */
-#ifdef SVR4
+#if defined SVR4
 static int	sed, nbra, circf;
 static char	*loc1, *loc2, *locs;
 static int 	advance();
@@ -1184,10 +1184,8 @@ static char	*compile();
 static int 	step();
 #endif /* SVR4 */
 
-
 #include <regexp.h>
 
-
 static void
 flist_compile_regex( private )
      File_list_private *private;
@@ -1197,8 +1195,8 @@ flist_compile_regex( private )
     size_t num_bytes;
 
     end_ptr
-	= compile( private->regex_pattern,
-		  compile_buf, 
+      = compile( private->regex_pattern,
+		  compile_buf,
 		  &(compile_buf[MAXPATHLEN+1]),
 		  '\0' );
 
@@ -1230,14 +1228,18 @@ flist_compile_regex( private )
 
     if (private->regex_compile == NULL) {
         private->regex_compile = xv_alloc_n(regex_t, 1);
+#ifndef __CYGWIN__
         private->regex_compile->__REPB_PREFIX(translate) = NULL;
+#endif
     }
+#ifndef __CYGWIN__
     if (private->regex_compile->__REPB_PREFIX(allocated) == 0) {
         private->regex_compile->__REPB_PREFIX(buffer) = xv_alloc_n(char, MAXPATHLEN + 1);
         private->regex_compile->__REPB_PREFIX(allocated) = MAXPATHLEN + 1;
     }
     re_compile_pattern(private->regex_pattern, strlen(private->regex_pattern),
 			private->regex_compile);
+#endif
 } 
 
 static int
@@ -1245,9 +1247,13 @@ flist_match_regex( s, private )
      char *s;
      File_list_private *private;
 {
+#ifndef __CYGWIN__
     if (private->regex_compile == NULL || private->regex_compile->__REPB_PREFIX(allocated) == 0)
         return 0;
     return (re_match(private->regex_compile, s, strlen(s), 0, NULL) != -1);
+#else
+    return 0;
+#endif
 }
 #endif /* __linux__ */
 /****************************************************************************/
--- origsrc/xview-3.2p1.4/lib/libxview/file_chooser/flist_impl.h	2013-02-23 14:43:41.609375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/file_chooser/flist_impl.h	2013-02-23 14:44:38.265625000 +0000
@@ -9,7 +9,7 @@
 
 #include <sys/param.h>
 #include <dirent.h>
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 #include <regex.h>
 #endif
 #include <xview_private/xv_path_util.h>
@@ -25,7 +25,7 @@ typedef struct {
     DIR *		dir_ptr;		/* cached directory pointer */
     char *		previous_dir;		/* last directory displayed */
     char *		regex_pattern; 		/* regular expression */
-#ifndef __linux__
+#if !defined __linux__ && !defined __CYGWIN__
     char *		regex_compile;		/* compiled form of regex */
 #else
     regex_t *           regex_compile;          /* compiled form of regex */
--- origsrc/xview-3.2p1.4/lib/libxview/filter/filter.c	2013-02-23 14:43:41.359375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/filter/filter.c	2013-02-23 14:44:44.000000000 +0000
@@ -41,7 +41,7 @@ char           *stream_fgets();
 
 static enum CharClass breakProc(char c);
 static struct CharAction digits(char c);
-static any_shell_meta(char  *s);
+static any_shell_meta_filter(char  *s);
 
 
 struct filter_rec **
@@ -114,7 +114,7 @@ xv_parse_filter_table(in, filename)
 	 * storage for stream allocated first time it is needed. subsequent
 	 * times, will be reused
 	 */
-	if (any_shell_meta(scratch)) {
+	if (any_shell_meta_filter(scratch)) {
 	    char           *shell;
 	    extern char    *getenv();
 
@@ -202,10 +202,10 @@ xv_free_filter_table(table)
 {
     int             i;
     for (i = 0; table[i] != NULL; i++) {
-	cfree((char *) table[i]->call);
+	free((char *) table[i]->call);
 	free((char *) table[i]);
     }
-    cfree((char *) table);
+    free((char *) table);
 }
 
 static struct CharAction
@@ -246,7 +246,7 @@ breakProc(c)
  * Are there any shell meta-characters in string s?
  */
 static
-any_shell_meta(s)
+any_shell_meta_filter(s)
     register char  *s;
 {
 
--- origsrc/xview-3.2p1.4/lib/libxview/frame/fm_impl.h	2013-02-23 14:43:42.484375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/frame/fm_impl.h	2013-02-23 14:44:38.343750000 +0000
@@ -18,7 +18,7 @@ static char     sccsid[] = "@(#)fm_impl.
 
 /* standard includes */
 #ifndef FILE
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
 #undef NULL
 #endif /* SVR4 */
 #include <stdio.h>
--- origsrc/xview-3.2p1.4/lib/libxview/frame/fm_props.h	2013-02-23 14:43:42.734375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/frame/fm_props.h	2013-02-23 14:44:38.343750000 +0000
@@ -14,7 +14,7 @@
 
 /* standard includes */
 #ifndef FILE
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
 #undef NULL
 #endif /* SVR4 */
 #include <stdio.h>
--- origsrc/xview-3.2p1.4/lib/libxview/frame/fm_rescale.c	2013-02-23 14:43:42.484375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/frame/fm_rescale.c	2013-02-23 14:44:38.343750000 +0000
@@ -43,7 +43,7 @@ frame_rescale_subwindows(frame_public, s
      */
     window_default_event_func(frame_public, (Event *) 0, scale, (Notify_event_type) 0);
     window_calculate_new_size(frame_public, frame_public, &frame_height, &frame_width);
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
     xv_set(frame_public, WIN_RECT, 0); /* This looks like a XView bug to me */
 #endif
 
--- origsrc/xview-3.2p1.4/lib/libxview/frame/frame_base.h	2013-02-23 14:43:42.562500000 +0000
+++ src/xview-3.2p1.4/lib/libxview/frame/frame_base.h	2013-02-23 14:44:38.343750000 +0000
@@ -18,7 +18,7 @@ static char     sccsid[] = "@(#)frame_ba
 
 /* standard includes */
 #ifndef FILE
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
 #undef NULL
 #endif /* SVR4 */
 #include <stdio.h>
--- origsrc/xview-3.2p1.4/lib/libxview/frame/frame_cmd.h	2013-02-23 14:43:42.734375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/frame/frame_cmd.h	2013-02-23 14:44:38.359375000 +0000
@@ -18,7 +18,7 @@ static char     sccsid[] = "@(#)frame_cm
 
 /* standard includes */
 #ifndef FILE
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
 #undef NULL
 #endif /* SVR4 */
 #include <stdio.h>
--- origsrc/xview-3.2p1.4/lib/libxview/frame/frame_help.h	2013-02-23 14:43:42.484375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/frame/frame_help.h	2013-02-23 14:44:38.359375000 +0000
@@ -18,7 +18,7 @@ static char     sccsid[] = "@(#)frame_he
 
 /* standard includes */
 #ifndef FILE
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
 #undef NULL
 #endif /* SVR4 */
 #include <stdio.h>
--- origsrc/xview-3.2p1.4/lib/libxview/help/help_file.c	2013-02-23 14:43:40.609375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/help/help_file.c	2013-02-23 14:44:38.359375000 +0000
@@ -18,7 +18,7 @@ static char     sccsid[] = "@(#)help_fil
 
 #include <xview_private/i18n_impl.h>
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 #define DEFAULT_HELP_DIRECTORY "/usr/lib/help"
 #else
 #if 1 /* FHS compliance, but search the old directories, too - mbuck@debian.org */
@@ -89,8 +89,9 @@ xv_help_find_file(filename)
 
    /*
     * Need to fix this to get the XV_LC_DISPLAY_LANG from server
+    *
     */
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
     if (_xv_use_locale)
     	xv_lc_display_lang = setlocale(LC_MESSAGES, NULL); 
 #else
--- origsrc/xview-3.2p1.4/lib/libxview/imcb/aux.c	1993-06-29 06:15:54.000000000 +0100
+++ src/xview-3.2p1.4/lib/libxview/imcb/aux.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,801 +0,0 @@
-#ifndef lint
-#ifdef sccs
-static char     sccsid[] = "@(#)aux.c 50.34 93/06/28";
-#endif
-#endif
-
-/*
- *	(c) Copyright 1989 Sun Microsystems, Inc. Sun design patents 
- *	pending in the U.S. and foreign countries. See LEGAL NOTICE 
- *	file for terms of the license.
- */
-
-
-
-#include <xview_private/i18n_impl.h>
-#include <xview/base.h>
-#include <xview/frame.h>
-#include <xview/panel.h>
-#include <xview/notice.h>
-#include <xview_private/panel_impl.h>
-#include <xview_private/aux.h>
-
-#define GET_EVENT
-#define	ITERM_BUFSIZE	1024
-
-void   			aux_unpin_proc();
-
-static Panel_setting	aux_post_event();
-static Bool		aux_start_called = FALSE;
-static Bool		aux_draw_called = FALSE;
-
-static AuxFrameInfo	*aux_frame_info = NULL;
-static AuxFrameInfo     *aux_get_frame();
-static Frame            aux_get_p_frame();
-static void             aux_get_win_position();
-
-#ifdef  GET_EVENT
-static    XKeyEvent     e;
-#endif
-
-static void             aux_get_defaults();
-static AuxDefaults	aux_defaults;
-
-/*#define	HACK	/* $@GO</$b!<$s!!C/$,$R$h$o$@$H!)(J */
-
-
-
-void
-aux_start (ic, client_data, callback_data)
-    XIC				ic;
-    XPointer			client_data;
-    XIMAuxStartCallbackStruct 	*callback_data;
-{
-    Panel_info	*panel;
-    wchar_t	*aux_label = (wchar_t *)NULL;
-    wchar_t	*aux_text = (wchar_t *)NULL;
-    AuxInfo     *info;
-    Item_info	*item_private;
-    XKeyEvent   *event = (XKeyEvent *)callback_data->event;
-
-    /* 
-     * Create aux info structure 
-     */
-    if( !aux_info_create(client_data) ) {
-	xv_error( NULL,
-		ERROR_STRING,
-		XV_MSG("Aux callback: out of memory"),
-		0 );
-    }
-    info = (AuxInfo *)AUX_UDATA_INFO(client_data);
-
-    /* 
-     * Initialize aux info structure 
-     */
-    info->ic = ic;
-    info->dpy = (Display *)XDisplayOfIM((XIM)XIMOfIC(ic));
-    info->pe_cache = (XIMPreeditDrawCallbackStruct *) 
-		     xv_alloc(XIMPreeditDrawCallbackStruct);
-    info->pe_cache->text = (XIMText *)xv_alloc(XIMText);
-
-    /* 
-     * Auxiliary Frame creation: 
-     * 
-     * Make sure to reuse the same aux command frame. Traverse back to 
-     * find the base window associated with the client window. Also make 
-     * sure aux region frame always comes up in the same x,y location 
-     * (ie. if user moves aux frame, remember those coordinates).
-     */
-    info->frame_info = aux_get_frame(info->dpy, callback_data);
-    info->frame = info->frame_info->frame;
-    if( !info->frame )
-        goto err_return;
-
-    /* 
-     * Disable input to the Auxialiary panel
-     */
-    info->panel = (Panel)xv_get(info->frame ,FRAME_CMD_PANEL, NULL);
-    if( !info->panel )
-        goto err_return;
-
-    xv_set(info->panel,
-            WIN_IGNORE_X_EVENT_MASK,
-	    (KeyPress|KeyRelease|ButtonPress|ButtonRelease), NULL);
-
-    /*
-     * Initialize Aux region panel items 
-     */
-    if( callback_data->label->length > 0 ) {
-    	if( callback_data->label->encoding_is_wchar )
-    		aux_label = callback_data->label->string.wide_char;
-    	else {
-       		int	len_plus_one;
-		len_plus_one = 1 + callback_data->label->length;
-		aux_label = (wchar_t *)malloc( len_plus_one * sizeof(wchar_t) );
-		mbstowcs(aux_label, callback_data->label->string.multi_byte, 
-				len_plus_one);
-   	 }
-    }
-
-    if( callback_data->text->length > 0 ) {
-    	if( callback_data->text->encoding_is_wchar )
-    		aux_text = callback_data->text->string.wide_char;
-    	else {
-        	int	len_plus_one;
-		len_plus_one = 1 + callback_data->text->length;
-		aux_text = (wchar_t *)malloc( len_plus_one * sizeof(wchar_t) );
-		mbstowcs(aux_text, callback_data->text->string.multi_byte, 
-				len_plus_one);
-    	}
-    }
-
-    if( aux_label  && aux_text ) {
-    	info->item = (Panel_item)xv_create( info->panel,	PANEL_TEXT,
-			XV_X,				10,
-			XV_Y,				10,
-			PANEL_LABEL_STRING_WCS,		aux_label,
-			PANEL_VALUE_STORED_LENGTH,	128,
-			PANEL_VALUE_WCS,		aux_text,
-			PANEL_NOTIFY_LEVEL,		PANEL_ALL,
-			PANEL_NOTIFY_PROC,		aux_post_event,
-			XV_KEY_DATA,	AUX_KEY_DATA,	info,
-			NULL );
-    }
-    else if( aux_label ) {
-	info->item = (Panel_item)xv_create( info->panel,        PANEL_TEXT,
-                        XV_X,                           10,
-                        XV_Y,                           10,
-                        PANEL_LABEL_STRING_WCS,         aux_label,
-			PANEL_VALUE_STORED_LENGTH,	128,
-                        PANEL_NOTIFY_LEVEL,             PANEL_ALL,
-                        PANEL_NOTIFY_PROC,              aux_post_event,
-                        XV_KEY_DATA,    AUX_KEY_DATA,   info,
-                        NULL );
-    }
-    else if ( aux_text ) {
-	info->item = (Panel_item)xv_create( info->panel,        PANEL_TEXT,
-                        XV_X,                           10,
-                        XV_Y,                           10,
-                        PANEL_VALUE_WCS,                aux_text,
-			PANEL_VALUE_STORED_LENGTH,	128,
-                        PANEL_NOTIFY_LEVEL,             PANEL_ALL,
-                        PANEL_NOTIFY_PROC,              aux_post_event,
-                        XV_KEY_DATA,    AUX_KEY_DATA,   info,
-                        NULL );
-    }
-    else {
-	info->item = (Panel_item)xv_create( info->panel,        PANEL_TEXT,
-                        XV_X,                           10,
-                        XV_Y,                           10,
-                        PANEL_NOTIFY_LEVEL,             PANEL_ALL,
-                        PANEL_NOTIFY_PROC,              aux_post_event,
-                        XV_KEY_DATA,    AUX_KEY_DATA,   info,
-                        NULL );
-    }
-
-
-    if( !callback_data->label->encoding_is_wchar
-		&& callback_data->label->length > 0 )
-	free(aux_label);
-    if( !callback_data->text->encoding_is_wchar 
-		&& callback_data->text->length > 0 )
-	free(aux_text);
-
-    if( !info->item )
-	goto err_return; 
-
-    /*
-     * Initialize preedit text for panel item
-     */
-/* get the private handle, allocate buffer for intermediate text and
- * attach it to the panel.
- */
-    panel = PANEL_PRIVATE(info->panel);
-    panel->preedit->text->string.wide_char = 
-	(wchar_t *) malloc(ITERM_BUFSIZE*sizeof(wchar_t));
-    panel->preedit->text->feedback =
-	(XIMFeedback *) malloc(ITERM_BUFSIZE* sizeof (XIMFeedback));
-
-    /* store the current_caret_offset */
-    item_private = ITEM_PRIVATE( info->item );
-    panel->preedit_item = panel->kbd_focus_item = item_private;
-    /*panel->kbd_focus_item->item_type = PANEL_TEXT_ITEM;*/
-    ml_panel_saved_caret(item_private);
-
-
-    /*
-     * We should fit the panel and frame as long as the user has not
-     * resized the Aux region.
-     */
-    if (info->frame_info->f_width == 0 && info->frame_info->f_height == 0) {
-
-	Rect	*rect;
-
-    	window_fit(info->panel);
-    	window_fit(info->frame);
-	rect = (Rect *)xv_get(info->frame, WIN_RECT);	
-/*
-	info->frame_info->f_x = rect->r_left;
-	info->frame_info->f_y = rect->r_top;
-*/
-	info->frame_info->f_width = rect->r_width;
-	info->frame_info->f_height = rect->r_height;
-    }
-
-    xv_set(info->frame ,XV_SHOW, TRUE, NULL );
-    
-    /*
-    return XIMCB_Success;
-    */
-
-    aux_start_called = TRUE;
-#ifdef  GET_EVENT
-    e = *(callback_data->event);
-#endif
-    return;
-
-    /*
-     * Error handling for auxiliary region creation failure.
-     */
-
-err_return:     /* xv-object creation failure */
-    xv_error( NULL,
-	ERROR_STRING,
-	XV_MSG("Aux callback: failed to create xv_object "),
-	0 );
-    /*
-    return XIMCB_FatalError;
-    */
-}
-
-
-aux_info_create( client_data )
-    XPointer        client_data;
-{
-    AuxInfo     *data;
-    Xv_opaque   *dum;
-	 
-    dum = (Xv_opaque *)client_data;
-    data = (AuxInfo *)malloc( sizeof( AuxInfo ) );
-    if( !data )
-     	return 0;
-    *dum = (Xv_opaque)data;
-     	return 1;
-}
-
-
-void
-aux_draw(ic, client_data, callback_data)
-    XIC					ic;
-    XPointer				client_data;
-    XIMPreeditDrawCallbackStruct        *callback_data;
-{
-    Panel_info 		*panel;
-    Item_info 		*ip, *item_private;
-    AuxInfo    		*info;
-    AuxFrameInfo	*afi;
-    int 		i, length;
-    XIMPreeditDrawCallbackStruct *preedit_changes;
-
-#ifdef	HACK
-    if( !aux_start_called ){
-	aux_start(ic, client_data, callback_data);
-	return;
-    }
-#endif
-
-    info = (AuxInfo *)AUX_UDATA_INFO(client_data);
-    panel = PANEL_PRIVATE(info->panel);
-
-    /* 
-     *  Figure out location and size of the aux frame window.
-     *  based on aux defaults, and can be reset by user.
-     */
-
-    if (aux_get_draw_info(info) < 0)
-	return;
-    afi = info->frame_info;
-
-    if (aux_defaults.window_should_fit) {
-
-       xv_set(afi->frame,
-		XV_X, afi->f_x,
-		XV_Y, afi->f_y,
-		XV_WIDTH, afi->f_width,
-		XV_HEIGHT, afi->f_height,
-		NULL);
-
-       if(xv_get(info->frame, XV_SHOW) == FALSE)
-         	xv_set(info->frame, XV_SHOW, TRUE, NULL);
-    }
-
-    ip = ITEM_PRIVATE( info->item );
-
-    preedit_changes = (XIMPreeditDrawCallbackStruct *)callback_data;
-
-    if (!aux_draw_called) {
-	/*
-	 *  If this is the first time that aux_draw is called 
-	 *  we need to copy ip->panel->preedit with a copy of
-	 *  the preedit info from the input window.
-	 */
-	ip->panel->preedit->caret = preedit_changes->caret;
-	ip->panel->preedit->chg_first = preedit_changes->chg_first;
-	ip->panel->preedit->chg_length = preedit_changes->chg_length;
-
-	if (preedit_changes->text) {
-	   ip->panel->preedit->text->length = preedit_changes->text->length;
-	   ip->panel->preedit->text->encoding_is_wchar = 
-		preedit_changes->text->encoding_is_wchar;
-	   if (ip->panel->preedit->text->encoding_is_wchar) {
-	      for (i = 0; i < preedit_changes->text->length; i++) {
-		   ip->panel->preedit->text->feedback[i] = 
-		     preedit_changes->text->feedback[i];
-		   ip->panel->preedit->text->string.wide_char[i] =
-		     preedit_changes->text->string.wide_char[i];
-	      }
-	   } else {
-	      for (i = 0; i < preedit_changes->text->length; i++) {
-		ip->panel->preedit->text->feedback[i] = 
-		     preedit_changes->text->feedback[i];
-		ip->panel->preedit->text->string.multi_byte[i] =
-		     preedit_changes->text->string.multi_byte[i];
-	      }
-	   }	   
-	}
-
-    }
-    else
-    	cache_text_state(preedit_changes, ip->panel->preedit);
-
-    /* Make sure we null terminate the string */
-    length = ip->panel->preedit->text->length;
-    ip->panel->preedit->text->string.wide_char[length] = 0;
-
-    if (preedit_changes->text) {
-       if (!preedit_changes->text->feedback)
-          XV_BZERO(ip->panel->preedit,
-          sizeof(XIMFeedback)*ip->panel->preedit->text->length);
-    }
-
-/* if (ip->ignore_im != TRUE) ml_panel_display_interm(ip);*/
-    ml_panel_display_interm(ip);
-
-    aux_draw_called = TRUE;
-
-    /*
-    return XIMCB_Success;
-    */
-    
-    return;
-}
-
-void
-aux_done(ic, client_data, callback_data)
-    XIC		ic;
-    XPointer	client_data;
-    XPointer	*callback_data;
-{
-    Panel_info *panel;
-    AuxInfo    *info;
-    Item_info  *item_private;
-
-    info = (AuxInfo *)AUX_UDATA_INFO(client_data);
-    panel = PANEL_PRIVATE(info->panel);
-    item_private = ITEM_PRIVATE( info->item );
-	
-
-    /* saved the caret offset */
-    ml_panel_saved_caret(item_private);
-
-    /*
-    free ((char *)item_private->panel->preedit);
-    free ((char *)item_private->panel->preedit->text->string.wide_char); 
-    item_private->panel->preedit->text->string.wide_char[0] = 0;
-    item_private->panel->preedit->text->length = 0;
-    */
-
-    xv_set(info->frame, XV_SHOW, FALSE, NULL);
-    xv_destroy(info->item); 
-    free( info );
-    
-    aux_start_called = FALSE;
-    aux_draw_called = FALSE;
-
-}	
-
-static Panel_setting	aux_post_event(item, event)
-    Panel_item	item;
-    Event	*event;
-{
-
-/*
- * Can not use Event proc. JOWN201  1/15/91 
- */
-    
-}
-
-void
-aux_resize_handler(frame, event, arg, type)
-        Window                  frame;
-        Event                   *event;
-        Notify_arg              arg;
-        Notify_event_type       type;
-{
-
-
-	/*
-	 *  If we get a resize event we want to resize the panel
-	 *  text item appropriately. (Ex. Should have PANEL_DISPLAY_LENGTH
-	 *  adjust appropriately, depending on size or width of the panel.)
-	 */
-        /* 
-	 * Make sure this is not a synthetic resize event.  
-	 * Synthetic resize events generated when window is moved.
-         */
-        if (event_action(event) == WIN_RESIZE && 
-            event_xevent(event)->xconfigure.send_event == 0) {
-
-	    Panel 	panel;
-	    Panel_item 	item;
-     	    Panel_info  *pprivate;
-            int         width, n, stored_length, display_length;
-
-	    panel = (Panel) xv_get(frame, FRAME_CMD_PANEL, NULL);
-            pprivate = PANEL_PRIVATE(panel);
-	    item = ITEM_PUBLIC(pprivate->preedit_item);
-
-	     (void)notify_next_event_func(frame, event, arg, type);
-
-            /*
-             * Set the display width of the fillin field to extend to the
-             * right edge of the panel.  This will vary depending on how the
-             * user resizes the tool
-             */
-             width = (int)xv_get(panel, XV_WIDTH) -
-                        (int)xv_get(item, PANEL_VALUE_X) - 5;
- 
-             n = width / (int)xv_get(xv_get(panel, XV_FONT), FONT_COLUMN_WIDTH);
- 
-	     stored_length = xv_get(item, PANEL_VALUE_STORED_LENGTH);
-	     display_length = xv_get(item, PANEL_VALUE_DISPLAY_LENGTH);
-             if (n < 5)
-                n = 5;
-             else if (n > stored_length) 
-                n = stored_length;
- 
-/*
-	     printf("width: %d, PANEL_VALUE_STORED_LENGTH: %d, PANEL_VALUE_DISPLAY_LENGTH: %d\n", width, stored_length, display_length);
-*/
-             xv_set(item, PANEL_VALUE_DISPLAY_LENGTH, n, 0);
-
-	     /* need to reset the rect information for frame info*/
-
-        } else {
-		(void)notify_next_event_func(frame, event, arg, type);
-	}
-}
-
-
-/*
- * Frame handler, it will cache the frame per base frame basis.
- */
-static AuxFrameInfo *
-aux_get_frame(dpy, cb_data)
-    Display				*dpy;
-    XIMAuxStartCallbackStruct		*cb_data;
-{
-    AuxFrameInfo	*afi;
-    AuxFrameInfo	*pafi;
-    XFontSetExtents	*font_set_extents;
-    Xv_object		 p_obj;
-    Frame		 p_frame;
-    Rect		*rect;
-    XFontStruct         *font_struct;
-
-    p_obj = (Xv_object) win_data(dpy, cb_data->event->window);
-    p_frame = aux_get_p_frame(p_obj);
-    for (pafi = afi = aux_frame_info; afi != NULL; pafi = afi, afi = afi->next)
-	if (afi->dpy == dpy && afi->p_frame == p_frame)
-	    break;
-
-    if (afi == NULL) {
-
-	if (aux_defaults.has_been_initialized == FALSE) {
-	    aux_get_defaults(XV_LC_INPUT_LANG);
-	    aux_defaults.has_been_initialized = TRUE;
-	}
-
-	if ((afi = (AuxFrameInfo *)xv_alloc(AuxFrameInfo)) == NULL)
-	    return NULL;
-	if (aux_frame_info == NULL)
-	    aux_frame_info = afi;
-	else
-	    pafi->next = afi;
-
-	/*
-	 * Find aux window position
-	 */
-	afi->dpy = dpy;
-	afi->p_obj = p_obj;
-	afi->p_frame = p_frame;
-	aux_get_win_position(afi, cb_data);
-
-	/*
-	 * Create command frame for Aux region
-	 */
-	afi->frame = (Frame) xv_create(afi->p_frame, FRAME_CMD,
-		XV_X,				afi->f_x,
-		XV_Y,				afi->f_y,
-		OPENWIN_NO_MARGIN,		TRUE,
-		FRAME_SHOW_RESIZE_CORNER,	TRUE,
-		FRAME_CLOSED,			FALSE,
-		XV_SHOW,			FALSE,
-		WIN_USE_IM,			FALSE,
-                FRAME_LABEL,
-			XV_MSG("Auxiliary Region"),
-		FRAME_CMD_POINTER_WARP,		FALSE,
-		WIN_SAVE_UNDER,			TRUE,
-		WIN_CONSUME_EVENT,		WIN_CONFIGURE_REQUEST,
-		FRAME_INHERIT_COLORS,		TRUE,
-		FRAME_DONE_PROC,		aux_unpin_proc,
-		NULL);
-	if (afi->frame == NULL)
-	    return NULL;
-
-	afi->f_xwin = xv_get(afi->frame, XV_XID);
-
-	if (aux_defaults.font_name != NULL) {
-		if ((afi->xv_font = xv_find(afi->frame, FONT,
-				FONT_SET_SPECIFIER,	aux_defaults.font_name,
-				NULL)) == NULL) {
-		    char	 buf[100];
-
-		    (void) sprintf(buf,
-		        XV_MSG("aux: font(%s) couldn't find, use default"),
-			aux_defaults.font_name);
-		    xv_error(NULL, ERROR_STRING, buf, NULL);
-		}
-	}
-
-	if (afi->xv_font == NULL)
-	    afi->xv_font = xv_get(afi->frame, XV_FONT);
-
-	afi->afont = (XFontSet) xv_get(afi->xv_font, XV_XID);
-	if ((font_struct = XQueryFont(dpy, afi->afont)) == NULL) {
-		/*
-		 * This should not happen, but if its ever happen.  We
-		 * should get around the problem, instead of just
-		 * telling the failar.
-		 */
-		return NULL;
-	}
-	afi->achar_width = font_struct->max_bounds.width;
-	/*
-	 * Should not free the font_struct here.  At least current
-	 * Sun's implementation of mltext refers to the same physical
-	 * structure by the Xlib(mltext) itself.
-	 */
-	afi->font_set = (XFontSet) xv_get(afi->xv_font, FONT_SET_ID);
-	font_set_extents = XExtentsOfFontSet(afi->font_set);
-	afi->char_ascent = -font_set_extents->max_logical_extent.y;
-	afi->char_descent = font_set_extents->max_logical_extent.height
-			  + font_set_extents->max_logical_extent.y;
-	/*
-	 * FIX_ME:
-	 * Waiting for the BugID 1062587 (Synopsis:  XExtentsOfFontSet
-	 * does not return right value for the
-	 * max_logical_extent.width) to be fixed.
-	 *
-	 * afi->char_width = font_set_extents->max_logical_extent.width;
-	 */
-	afi->char_width = font_set_extents->max_ink_extent.width;
-	afi->char_height = font_set_extents->max_logical_extent.height;
-
-	afi->panel = (Panel) xv_get(afi->frame, FRAME_CMD_PANEL,
-				    NULL);
-
-        notify_interpose_event_func(afi->frame, aux_resize_handler, NOTIFY_SAFE);
-	afi->f_width = 0;
-	afi->f_height = 0;
-    } else {
-	rect = (Rect *) xv_get(afi->frame, WIN_RECT);
-	afi->f_x = rect->r_left;
-	afi->f_y = rect->r_top;
-	afi->f_width = rect->r_width;
-	afi->f_height = rect->r_height;
-    }
-
-    return afi;
-}
-
-
-/*
- * This function gets handlers of pre-edit windows.( Frame and the
- * associated object ) to enable Aux frame a command-frame, and also,
- * to make keyboard grab possible.
- */
-static Frame
-aux_get_p_frame(p_obj)
-    Xv_object	p_obj;
-{
-    int         is_subframe;
-    Frame	p_frame;
-
-    p_frame = (Frame) xv_get(p_obj, WIN_FRAME);
-    is_subframe = (int) xv_get(xv_get(p_frame, WIN_OWNER),
-			       XV_IS_SUBTYPE_OF, FRAME_CLASS);
-    if (is_subframe) 
-	p_frame = (Frame) xv_get(p_frame, WIN_OWNER);
-
-    return p_frame;
-}
-
-
-static void
-aux_get_win_position(afi, cb_data)
-    register AuxFrameInfo		*afi;
-    XIMLookupStartCallbackStruct        *cb_data;
-{
-    Display	*dpy;
-    Rect	*rect;
-
-    
- /** overall window geometry **/
-#ifdef  GET_EVENT
-    dpy = afi->dpy;
-
-    afi->sc_width = DisplayWidth(dpy, DefaultScreen(dpy));
-    afi->sc_height = DisplayHeight(dpy, DefaultScreen(dpy));
-
-    rect = (Rect *) xv_get(afi->p_frame, WIN_RECT);
-
-    /* 
-     * Position aux frame relative to the parent frame
-     */
-    afi->f_x = rect->r_left + aux_defaults.window_off_x;
-    afi->f_y = rect->r_top + aux_defaults.window_off_y;
-
-#else
-    info->sc_x = DisplayWidth(info->dpy, DefaultScreen(info->dpy));
-    info->sc_y = DisplayHeight(info->dpy, DefaultScreen(info->dpy));
-    info->f_x = 100;
-    info->f_y = 100;
-#endif   
-}
-
-void
-aux_unpin_proc(frame)
-   Frame		frame;
-{
-
-	notice_prompt(frame, NULL,
-        	NOTICE_MESSAGE_STRING,
-                XV_MSG("You are in conversion mode.\n\
-Auxialiary Region window cannot be dismissed."),
-                NOTICE_BUTTON, XV_MSG("Continue"),
-                NULL);
-
-}
-
-
-/*
- * This function retrieves user-preference setings from resource
- * database.
- */
-static void
-aux_get_defaults(locale)
-    Attr_attribute      locale;
-{
-        
-    defaults_set_locale(NULL, locale);
- 
-    aux_defaults.keygrab = defaults_get_boolean("aux.keygrab",
-                                                "Aux.Keygrab",
-                                                TRUE);
- 
-    aux_defaults.threed = defaults_get_boolean("OpenWindows.3DLook.Color",
-                                            
-                                               "OpenWindows.3DLook.Color",
-                                               TRUE);
- 
-    if ((aux_defaults.font_name = defaults_get_string("aux.font",
-                                                      "Aux.Font",
-                                                      NULL)) != NULL)
-        aux_defaults.font_name = xv_strsave(aux_defaults.font_name);
- 
- 
-/*
-    aux_defaults.window_margin_x
-                = defaults_get_integer_check("aux.window.margin.x",
-                                             "Aux.Window.Margin.X",
-                                             15, 0, 100000);
-    aux_defaults.window_margin_y
-                = defaults_get_integer_check("aux.window.margin.y",
-                                             "Aux.Window.Margin.Y",
-                                             15, 0, 100000);
-*/
-    /* 
-     * Horizontal and vertical offset of aux region window from
-     * base window.
-     */
-    aux_defaults.window_off_x
-                = defaults_get_integer_check("aux.window.off.x",
-                                             "Aux.Window.Off.X",
-                                             20, 0, 100000);
-    aux_defaults.window_off_y
-                = defaults_get_integer_check("aux.window.off.y",
-                                             "Aux.Window.Off.Y",
-                                             10, 0, 100000);
-/*
-    aux_defaults.window_width
-                = defaults_get_integer_check("aux.window.width",
-                                             "Aux.Window.width",
-                                             20, 0, 100000);
-    aux_defaults.window_height
-                = defaults_get_integer_check("aux.window.height",
-                                             "Aux.Window.height",
-                                             10, 0, 100000);
-*/
-    /* 
-     * If true, aux region will try to fit within the screen 
-     */
-    aux_defaults.window_should_fit
-                = defaults_get_boolean("aux.window.fit",
-                                       "Aux.Window.Fit", TRUE);
-
-    /* 
-     * Horizontal and vertical screen margin used when 
-     * aux_defaults.window_should_fit is TRUE.
-     */
-    aux_defaults.screen_margin_x
-                = defaults_get_integer_check("aux.screen.margin.x",
-                                             "Aux.Screen.Margin.X",
-                                             20, 0, 100000);
-    aux_defaults.screen_margin_y
-                = defaults_get_integer_check("aux.screen.margin.y",
-                                             "Aux.Screen.Margin.Y",
-                                             20, 0, 100000);
- 
-    defaults_set_locale(NULL, XV_NULL);
-}
-
-/*
- *       This function sets geometry of AUX window.
- */
-static
-aux_get_draw_info(info)
-    register AuxInfo    *info;
-{
-    AuxFrameInfo        *afi;
-    Rect		*rect;
-
-
-    afi = info->frame_info;
-
-    rect = (Rect *)xv_get(afi->frame, WIN_RECT);
-    afi->f_x = rect->r_left;
-    afi->f_y = rect->r_top;
-    afi->f_width = rect->r_width;
-    afi->f_height = rect->r_height;
-    /*   
-     * Now, make sure new window fits into the screen.
-     */
-    if (aux_defaults.window_should_fit) {
-    	if ((afi->f_width + afi->f_x)
-             > (afi->sc_width - aux_defaults.screen_margin_x))
-            afi->f_x = afi->sc_width - afi->f_width
-                        - aux_defaults.screen_margin_x;
-    	if (afi->f_x < aux_defaults.screen_margin_x)
-            afi->f_x = aux_defaults.screen_margin_x;
- 
-        if ((afi->f_height + afi->f_y)
-             > (afi->sc_height - aux_defaults.screen_margin_y))
-            afi->f_y = afi->sc_height - afi->f_height
-                        - aux_defaults.screen_margin_y;
-    	if (afi->f_y < aux_defaults.screen_margin_y)
-            afi->f_y = aux_defaults.screen_margin_y;
-    }
- 
-    return 0;
-}
--- origsrc/xview-3.2p1.4/lib/libxview/imcb/aux.h	2013-02-23 14:43:39.109375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/imcb/aux.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,88 +0,0 @@
-/*      "@(#)aux.h 50.9 93/06/28"		 */
-
-/*
- *      (c) Copyright 1989 Sun Microsystems, Inc. Sun design patents 
- *      pending in the U.S. and foreign countries. See LEGAL NOTICE 
- *      file for terms of the license.
- */
-
-#ifndef	aux_DEFINED
-#define	aux_DEFINED
-
-#define	AUX_UDATA_INFO(udata)	((AuxInfo *)(*(Xv_opaque *)udata))
-#define	AUX_KEY_DATA		101
-
-/*
- * Frame info for the auxiliary region, aux will share the frame per base 
- * frame basis.
- */
-typedef struct _aux_frame_info {
-    Display                *dpy;
-    int                    sc_width;      /* screen width */
-    int                    sc_height;     /* screen hight */
- 
-    Xv_object              p_obj;
-    Frame                  p_frame;       /* Parent frame */
- 
-    Frame                  frame;
-    XID                    f_xwin;
-    int                    f_x;           /* frame position */
-    int                    f_y;
-    int                    f_width;       /* frame size */
-    int                    f_height;
- 
-    Xv_Font                xv_font;       /* font in AUX */
-    XID                    afont;         /* ASCII font */
-    int                    achar_width;
- 
-    XFontSet               font_set;
-    int                    char_ascent;
-    int                    char_descent;
-    int                    char_width;
-    int                    char_height;
- 
-    Panel                  panel;
-    Panel_item             panel_item;
- 
-    struct _aux_frame_info *next;
-} AuxFrameInfo;
-
-typedef struct _aux_default {
-    Bool                 has_been_initialized;
- 
-    Bool                 keygrab;
-    Bool                 threed;
-    char                *font_name;
- 
-    int                  window_margin_x;
-    int                  window_margin_y;
-    Bool                 window_should_fit;     /*
-                                                 * aux window will fit
-                                                 * within the screen.
-                                                 */
-    int                  window_off_x;  /* Offset from parent window */
-    int                  window_off_y;
-    int                  screen_margin_x;
-    int                  screen_margin_y;
- 
-} AuxDefaults;
-	
-typedef	struct _aux_info {
-	Display				*dpy;
-	XIC				ic;
-	Bool				state;
-	Frame				frame;
-	Panel				panel;
-	Panel_item			item;
-	Xv_object			p_obj;
-        Frame				p_frame;
-
-	XIMPreeditDrawCallbackStruct	*pe_cache;
-	AuxFrameInfo			*frame_info;
-	int				f_x;
-	int				f_y;
-	int				f_width;
-	int				f_height;
-}  AuxInfo;
-
-#endif		/* ~aux_DEFINED */
--- origsrc/xview-3.2p1.4/lib/libxview/imcb/xaux.c	1970-01-01 01:00:00.000000000 +0100
+++ src/xview-3.2p1.4/lib/libxview/imcb/xaux.c	2013-02-23 14:44:38.375000000 +0000
@@ -0,0 +1,801 @@
+#ifndef lint
+#ifdef sccs
+static char     sccsid[] = "@(#)aux.c 50.34 93/06/28";
+#endif
+#endif
+
+/*
+ *	(c) Copyright 1989 Sun Microsystems, Inc. Sun design patents 
+ *	pending in the U.S. and foreign countries. See LEGAL NOTICE 
+ *	file for terms of the license.
+ */
+
+
+
+#include <xview_private/i18n_impl.h>
+#include <xview/base.h>
+#include <xview/frame.h>
+#include <xview/panel.h>
+#include <xview/notice.h>
+#include <xview_private/panel_impl.h>
+#include <xview_private/aux.h>
+
+#define GET_EVENT
+#define	ITERM_BUFSIZE	1024
+
+void   			aux_unpin_proc();
+
+static Panel_setting	aux_post_event();
+static Bool		aux_start_called = FALSE;
+static Bool		aux_draw_called = FALSE;
+
+static AuxFrameInfo	*aux_frame_info = NULL;
+static AuxFrameInfo     *aux_get_frame();
+static Frame            aux_get_p_frame();
+static void             aux_get_win_position();
+
+#ifdef  GET_EVENT
+static    XKeyEvent     e;
+#endif
+
+static void             aux_get_defaults();
+static AuxDefaults	aux_defaults;
+
+/*#define	HACK	/* $@GO</$b!<$s!!C/$,$R$h$o$@$H!)(J */
+
+
+
+void
+aux_start (ic, client_data, callback_data)
+    XIC				ic;
+    XPointer			client_data;
+    XIMAuxStartCallbackStruct 	*callback_data;
+{
+    Panel_info	*panel;
+    wchar_t	*aux_label = (wchar_t *)NULL;
+    wchar_t	*aux_text = (wchar_t *)NULL;
+    AuxInfo     *info;
+    Item_info	*item_private;
+    XKeyEvent   *event = (XKeyEvent *)callback_data->event;
+
+    /* 
+     * Create aux info structure 
+     */
+    if( !aux_info_create(client_data) ) {
+	xv_error( NULL,
+		ERROR_STRING,
+		XV_MSG("Aux callback: out of memory"),
+		0 );
+    }
+    info = (AuxInfo *)AUX_UDATA_INFO(client_data);
+
+    /* 
+     * Initialize aux info structure 
+     */
+    info->ic = ic;
+    info->dpy = (Display *)XDisplayOfIM((XIM)XIMOfIC(ic));
+    info->pe_cache = (XIMPreeditDrawCallbackStruct *) 
+		     xv_alloc(XIMPreeditDrawCallbackStruct);
+    info->pe_cache->text = (XIMText *)xv_alloc(XIMText);
+
+    /* 
+     * Auxiliary Frame creation: 
+     * 
+     * Make sure to reuse the same aux command frame. Traverse back to 
+     * find the base window associated with the client window. Also make 
+     * sure aux region frame always comes up in the same x,y location 
+     * (ie. if user moves aux frame, remember those coordinates).
+     */
+    info->frame_info = aux_get_frame(info->dpy, callback_data);
+    info->frame = info->frame_info->frame;
+    if( !info->frame )
+        goto err_return;
+
+    /* 
+     * Disable input to the Auxialiary panel
+     */
+    info->panel = (Panel)xv_get(info->frame ,FRAME_CMD_PANEL, NULL);
+    if( !info->panel )
+        goto err_return;
+
+    xv_set(info->panel,
+            WIN_IGNORE_X_EVENT_MASK,
+	    (KeyPress|KeyRelease|ButtonPress|ButtonRelease), NULL);
+
+    /*
+     * Initialize Aux region panel items 
+     */
+    if( callback_data->label->length > 0 ) {
+    	if( callback_data->label->encoding_is_wchar )
+    		aux_label = callback_data->label->string.wide_char;
+    	else {
+       		int	len_plus_one;
+		len_plus_one = 1 + callback_data->label->length;
+		aux_label = (wchar_t *)malloc( len_plus_one * sizeof(wchar_t) );
+		mbstowcs(aux_label, callback_data->label->string.multi_byte, 
+				len_plus_one);
+   	 }
+    }
+
+    if( callback_data->text->length > 0 ) {
+    	if( callback_data->text->encoding_is_wchar )
+    		aux_text = callback_data->text->string.wide_char;
+    	else {
+        	int	len_plus_one;
+		len_plus_one = 1 + callback_data->text->length;
+		aux_text = (wchar_t *)malloc( len_plus_one * sizeof(wchar_t) );
+		mbstowcs(aux_text, callback_data->text->string.multi_byte, 
+				len_plus_one);
+    	}
+    }
+
+    if( aux_label  && aux_text ) {
+    	info->item = (Panel_item)xv_create( info->panel,	PANEL_TEXT,
+			XV_X,				10,
+			XV_Y,				10,
+			PANEL_LABEL_STRING_WCS,		aux_label,
+			PANEL_VALUE_STORED_LENGTH,	128,
+			PANEL_VALUE_WCS,		aux_text,
+			PANEL_NOTIFY_LEVEL,		PANEL_ALL,
+			PANEL_NOTIFY_PROC,		aux_post_event,
+			XV_KEY_DATA,	AUX_KEY_DATA,	info,
+			NULL );
+    }
+    else if( aux_label ) {
+	info->item = (Panel_item)xv_create( info->panel,        PANEL_TEXT,
+                        XV_X,                           10,
+                        XV_Y,                           10,
+                        PANEL_LABEL_STRING_WCS,         aux_label,
+			PANEL_VALUE_STORED_LENGTH,	128,
+                        PANEL_NOTIFY_LEVEL,             PANEL_ALL,
+                        PANEL_NOTIFY_PROC,              aux_post_event,
+                        XV_KEY_DATA,    AUX_KEY_DATA,   info,
+                        NULL );
+    }
+    else if ( aux_text ) {
+	info->item = (Panel_item)xv_create( info->panel,        PANEL_TEXT,
+                        XV_X,                           10,
+                        XV_Y,                           10,
+                        PANEL_VALUE_WCS,                aux_text,
+			PANEL_VALUE_STORED_LENGTH,	128,
+                        PANEL_NOTIFY_LEVEL,             PANEL_ALL,
+                        PANEL_NOTIFY_PROC,              aux_post_event,
+                        XV_KEY_DATA,    AUX_KEY_DATA,   info,
+                        NULL );
+    }
+    else {
+	info->item = (Panel_item)xv_create( info->panel,        PANEL_TEXT,
+                        XV_X,                           10,
+                        XV_Y,                           10,
+                        PANEL_NOTIFY_LEVEL,             PANEL_ALL,
+                        PANEL_NOTIFY_PROC,              aux_post_event,
+                        XV_KEY_DATA,    AUX_KEY_DATA,   info,
+                        NULL );
+    }
+
+
+    if( !callback_data->label->encoding_is_wchar
+		&& callback_data->label->length > 0 )
+	free(aux_label);
+    if( !callback_data->text->encoding_is_wchar 
+		&& callback_data->text->length > 0 )
+	free(aux_text);
+
+    if( !info->item )
+	goto err_return; 
+
+    /*
+     * Initialize preedit text for panel item
+     */
+/* get the private handle, allocate buffer for intermediate text and
+ * attach it to the panel.
+ */
+    panel = PANEL_PRIVATE(info->panel);
+    panel->preedit->text->string.wide_char = 
+	(wchar_t *) malloc(ITERM_BUFSIZE*sizeof(wchar_t));
+    panel->preedit->text->feedback =
+	(XIMFeedback *) malloc(ITERM_BUFSIZE* sizeof (XIMFeedback));
+
+    /* store the current_caret_offset */
+    item_private = ITEM_PRIVATE( info->item );
+    panel->preedit_item = panel->kbd_focus_item = item_private;
+    /*panel->kbd_focus_item->item_type = PANEL_TEXT_ITEM;*/
+    ml_panel_saved_caret(item_private);
+
+
+    /*
+     * We should fit the panel and frame as long as the user has not
+     * resized the Aux region.
+     */
+    if (info->frame_info->f_width == 0 && info->frame_info->f_height == 0) {
+
+	Rect	*rect;
+
+    	window_fit(info->panel);
+    	window_fit(info->frame);
+	rect = (Rect *)xv_get(info->frame, WIN_RECT);	
+/*
+	info->frame_info->f_x = rect->r_left;
+	info->frame_info->f_y = rect->r_top;
+*/
+	info->frame_info->f_width = rect->r_width;
+	info->frame_info->f_height = rect->r_height;
+    }
+
+    xv_set(info->frame ,XV_SHOW, TRUE, NULL );
+    
+    /*
+    return XIMCB_Success;
+    */
+
+    aux_start_called = TRUE;
+#ifdef  GET_EVENT
+    e = *(callback_data->event);
+#endif
+    return;
+
+    /*
+     * Error handling for auxiliary region creation failure.
+     */
+
+err_return:     /* xv-object creation failure */
+    xv_error( NULL,
+	ERROR_STRING,
+	XV_MSG("Aux callback: failed to create xv_object "),
+	0 );
+    /*
+    return XIMCB_FatalError;
+    */
+}
+
+
+aux_info_create( client_data )
+    XPointer        client_data;
+{
+    AuxInfo     *data;
+    Xv_opaque   *dum;
+	 
+    dum = (Xv_opaque *)client_data;
+    data = (AuxInfo *)malloc( sizeof( AuxInfo ) );
+    if( !data )
+     	return 0;
+    *dum = (Xv_opaque)data;
+     	return 1;
+}
+
+
+void
+aux_draw(ic, client_data, callback_data)
+    XIC					ic;
+    XPointer				client_data;
+    XIMPreeditDrawCallbackStruct        *callback_data;
+{
+    Panel_info 		*panel;
+    Item_info 		*ip, *item_private;
+    AuxInfo    		*info;
+    AuxFrameInfo	*afi;
+    int 		i, length;
+    XIMPreeditDrawCallbackStruct *preedit_changes;
+
+#ifdef	HACK
+    if( !aux_start_called ){
+	aux_start(ic, client_data, callback_data);
+	return;
+    }
+#endif
+
+    info = (AuxInfo *)AUX_UDATA_INFO(client_data);
+    panel = PANEL_PRIVATE(info->panel);
+
+    /* 
+     *  Figure out location and size of the aux frame window.
+     *  based on aux defaults, and can be reset by user.
+     */
+
+    if (aux_get_draw_info(info) < 0)
+	return;
+    afi = info->frame_info;
+
+    if (aux_defaults.window_should_fit) {
+
+       xv_set(afi->frame,
+		XV_X, afi->f_x,
+		XV_Y, afi->f_y,
+		XV_WIDTH, afi->f_width,
+		XV_HEIGHT, afi->f_height,
+		NULL);
+
+       if(xv_get(info->frame, XV_SHOW) == FALSE)
+         	xv_set(info->frame, XV_SHOW, TRUE, NULL);
+    }
+
+    ip = ITEM_PRIVATE( info->item );
+
+    preedit_changes = (XIMPreeditDrawCallbackStruct *)callback_data;
+
+    if (!aux_draw_called) {
+	/*
+	 *  If this is the first time that aux_draw is called 
+	 *  we need to copy ip->panel->preedit with a copy of
+	 *  the preedit info from the input window.
+	 */
+	ip->panel->preedit->caret = preedit_changes->caret;
+	ip->panel->preedit->chg_first = preedit_changes->chg_first;
+	ip->panel->preedit->chg_length = preedit_changes->chg_length;
+
+	if (preedit_changes->text) {
+	   ip->panel->preedit->text->length = preedit_changes->text->length;
+	   ip->panel->preedit->text->encoding_is_wchar = 
+		preedit_changes->text->encoding_is_wchar;
+	   if (ip->panel->preedit->text->encoding_is_wchar) {
+	      for (i = 0; i < preedit_changes->text->length; i++) {
+		   ip->panel->preedit->text->feedback[i] = 
+		     preedit_changes->text->feedback[i];
+		   ip->panel->preedit->text->string.wide_char[i] =
+		     preedit_changes->text->string.wide_char[i];
+	      }
+	   } else {
+	      for (i = 0; i < preedit_changes->text->length; i++) {
+		ip->panel->preedit->text->feedback[i] = 
+		     preedit_changes->text->feedback[i];
+		ip->panel->preedit->text->string.multi_byte[i] =
+		     preedit_changes->text->string.multi_byte[i];
+	      }
+	   }	   
+	}
+
+    }
+    else
+    	cache_text_state(preedit_changes, ip->panel->preedit);
+
+    /* Make sure we null terminate the string */
+    length = ip->panel->preedit->text->length;
+    ip->panel->preedit->text->string.wide_char[length] = 0;
+
+    if (preedit_changes->text) {
+       if (!preedit_changes->text->feedback)
+          XV_BZERO(ip->panel->preedit,
+          sizeof(XIMFeedback)*ip->panel->preedit->text->length);
+    }
+
+/* if (ip->ignore_im != TRUE) ml_panel_display_interm(ip);*/
+    ml_panel_display_interm(ip);
+
+    aux_draw_called = TRUE;
+
+    /*
+    return XIMCB_Success;
+    */
+    
+    return;
+}
+
+void
+aux_done(ic, client_data, callback_data)
+    XIC		ic;
+    XPointer	client_data;
+    XPointer	*callback_data;
+{
+    Panel_info *panel;
+    AuxInfo    *info;
+    Item_info  *item_private;
+
+    info = (AuxInfo *)AUX_UDATA_INFO(client_data);
+    panel = PANEL_PRIVATE(info->panel);
+    item_private = ITEM_PRIVATE( info->item );
+	
+
+    /* saved the caret offset */
+    ml_panel_saved_caret(item_private);
+
+    /*
+    free ((char *)item_private->panel->preedit);
+    free ((char *)item_private->panel->preedit->text->string.wide_char); 
+    item_private->panel->preedit->text->string.wide_char[0] = 0;
+    item_private->panel->preedit->text->length = 0;
+    */
+
+    xv_set(info->frame, XV_SHOW, FALSE, NULL);
+    xv_destroy(info->item); 
+    free( info );
+    
+    aux_start_called = FALSE;
+    aux_draw_called = FALSE;
+
+}	
+
+static Panel_setting	aux_post_event(item, event)
+    Panel_item	item;
+    Event	*event;
+{
+
+/*
+ * Can not use Event proc. JOWN201  1/15/91 
+ */
+    
+}
+
+void
+aux_resize_handler(frame, event, arg, type)
+        Window                  frame;
+        Event                   *event;
+        Notify_arg              arg;
+        Notify_event_type       type;
+{
+
+
+	/*
+	 *  If we get a resize event we want to resize the panel
+	 *  text item appropriately. (Ex. Should have PANEL_DISPLAY_LENGTH
+	 *  adjust appropriately, depending on size or width of the panel.)
+	 */
+        /* 
+	 * Make sure this is not a synthetic resize event.  
+	 * Synthetic resize events generated when window is moved.
+         */
+        if (event_action(event) == WIN_RESIZE && 
+            event_xevent(event)->xconfigure.send_event == 0) {
+
+	    Panel 	panel;
+	    Panel_item 	item;
+     	    Panel_info  *pprivate;
+            int         width, n, stored_length, display_length;
+
+	    panel = (Panel) xv_get(frame, FRAME_CMD_PANEL, NULL);
+            pprivate = PANEL_PRIVATE(panel);
+	    item = ITEM_PUBLIC(pprivate->preedit_item);
+
+	     (void)notify_next_event_func(frame, event, arg, type);
+
+            /*
+             * Set the display width of the fillin field to extend to the
+             * right edge of the panel.  This will vary depending on how the
+             * user resizes the tool
+             */
+             width = (int)xv_get(panel, XV_WIDTH) -
+                        (int)xv_get(item, PANEL_VALUE_X) - 5;
+ 
+             n = width / (int)xv_get(xv_get(panel, XV_FONT), FONT_COLUMN_WIDTH);
+ 
+	     stored_length = xv_get(item, PANEL_VALUE_STORED_LENGTH);
+	     display_length = xv_get(item, PANEL_VALUE_DISPLAY_LENGTH);
+             if (n < 5)
+                n = 5;
+             else if (n > stored_length) 
+                n = stored_length;
+ 
+/*
+	     printf("width: %d, PANEL_VALUE_STORED_LENGTH: %d, PANEL_VALUE_DISPLAY_LENGTH: %d\n", width, stored_length, display_length);
+*/
+             xv_set(item, PANEL_VALUE_DISPLAY_LENGTH, n, 0);
+
+	     /* need to reset the rect information for frame info*/
+
+        } else {
+		(void)notify_next_event_func(frame, event, arg, type);
+	}
+}
+
+
+/*
+ * Frame handler, it will cache the frame per base frame basis.
+ */
+static AuxFrameInfo *
+aux_get_frame(dpy, cb_data)
+    Display				*dpy;
+    XIMAuxStartCallbackStruct		*cb_data;
+{
+    AuxFrameInfo	*afi;
+    AuxFrameInfo	*pafi;
+    XFontSetExtents	*font_set_extents;
+    Xv_object		 p_obj;
+    Frame		 p_frame;
+    Rect		*rect;
+    XFontStruct         *font_struct;
+
+    p_obj = (Xv_object) win_data(dpy, cb_data->event->window);
+    p_frame = aux_get_p_frame(p_obj);
+    for (pafi = afi = aux_frame_info; afi != NULL; pafi = afi, afi = afi->next)
+	if (afi->dpy == dpy && afi->p_frame == p_frame)
+	    break;
+
+    if (afi == NULL) {
+
+	if (aux_defaults.has_been_initialized == FALSE) {
+	    aux_get_defaults(XV_LC_INPUT_LANG);
+	    aux_defaults.has_been_initialized = TRUE;
+	}
+
+	if ((afi = (AuxFrameInfo *)xv_alloc(AuxFrameInfo)) == NULL)
+	    return NULL;
+	if (aux_frame_info == NULL)
+	    aux_frame_info = afi;
+	else
+	    pafi->next = afi;
+
+	/*
+	 * Find aux window position
+	 */
+	afi->dpy = dpy;
+	afi->p_obj = p_obj;
+	afi->p_frame = p_frame;
+	aux_get_win_position(afi, cb_data);
+
+	/*
+	 * Create command frame for Aux region
+	 */
+	afi->frame = (Frame) xv_create(afi->p_frame, FRAME_CMD,
+		XV_X,				afi->f_x,
+		XV_Y,				afi->f_y,
+		OPENWIN_NO_MARGIN,		TRUE,
+		FRAME_SHOW_RESIZE_CORNER,	TRUE,
+		FRAME_CLOSED,			FALSE,
+		XV_SHOW,			FALSE,
+		WIN_USE_IM,			FALSE,
+                FRAME_LABEL,
+			XV_MSG("Auxiliary Region"),
+		FRAME_CMD_POINTER_WARP,		FALSE,
+		WIN_SAVE_UNDER,			TRUE,
+		WIN_CONSUME_EVENT,		WIN_CONFIGURE_REQUEST,
+		FRAME_INHERIT_COLORS,		TRUE,
+		FRAME_DONE_PROC,		aux_unpin_proc,
+		NULL);
+	if (afi->frame == NULL)
+	    return NULL;
+
+	afi->f_xwin = xv_get(afi->frame, XV_XID);
+
+	if (aux_defaults.font_name != NULL) {
+		if ((afi->xv_font = xv_find(afi->frame, FONT,
+				FONT_SET_SPECIFIER,	aux_defaults.font_name,
+				NULL)) == NULL) {
+		    char	 buf[100];
+
+		    (void) sprintf(buf,
+		        XV_MSG("aux: font(%s) couldn't find, use default"),
+			aux_defaults.font_name);
+		    xv_error(NULL, ERROR_STRING, buf, NULL);
+		}
+	}
+
+	if (afi->xv_font == NULL)
+	    afi->xv_font = xv_get(afi->frame, XV_FONT);
+
+	afi->afont = (XFontSet) xv_get(afi->xv_font, XV_XID);
+	if ((font_struct = XQueryFont(dpy, afi->afont)) == NULL) {
+		/*
+		 * This should not happen, but if its ever happen.  We
+		 * should get around the problem, instead of just
+		 * telling the failar.
+		 */
+		return NULL;
+	}
+	afi->achar_width = font_struct->max_bounds.width;
+	/*
+	 * Should not free the font_struct here.  At least current
+	 * Sun's implementation of mltext refers to the same physical
+	 * structure by the Xlib(mltext) itself.
+	 */
+	afi->font_set = (XFontSet) xv_get(afi->xv_font, FONT_SET_ID);
+	font_set_extents = XExtentsOfFontSet(afi->font_set);
+	afi->char_ascent = -font_set_extents->max_logical_extent.y;
+	afi->char_descent = font_set_extents->max_logical_extent.height
+			  + font_set_extents->max_logical_extent.y;
+	/*
+	 * FIX_ME:
+	 * Waiting for the BugID 1062587 (Synopsis:  XExtentsOfFontSet
+	 * does not return right value for the
+	 * max_logical_extent.width) to be fixed.
+	 *
+	 * afi->char_width = font_set_extents->max_logical_extent.width;
+	 */
+	afi->char_width = font_set_extents->max_ink_extent.width;
+	afi->char_height = font_set_extents->max_logical_extent.height;
+
+	afi->panel = (Panel) xv_get(afi->frame, FRAME_CMD_PANEL,
+				    NULL);
+
+        notify_interpose_event_func(afi->frame, aux_resize_handler, NOTIFY_SAFE);
+	afi->f_width = 0;
+	afi->f_height = 0;
+    } else {
+	rect = (Rect *) xv_get(afi->frame, WIN_RECT);
+	afi->f_x = rect->r_left;
+	afi->f_y = rect->r_top;
+	afi->f_width = rect->r_width;
+	afi->f_height = rect->r_height;
+    }
+
+    return afi;
+}
+
+
+/*
+ * This function gets handlers of pre-edit windows.( Frame and the
+ * associated object ) to enable Aux frame a command-frame, and also,
+ * to make keyboard grab possible.
+ */
+static Frame
+aux_get_p_frame(p_obj)
+    Xv_object	p_obj;
+{
+    int         is_subframe;
+    Frame	p_frame;
+
+    p_frame = (Frame) xv_get(p_obj, WIN_FRAME);
+    is_subframe = (int) xv_get(xv_get(p_frame, WIN_OWNER),
+			       XV_IS_SUBTYPE_OF, FRAME_CLASS);
+    if (is_subframe) 
+	p_frame = (Frame) xv_get(p_frame, WIN_OWNER);
+
+    return p_frame;
+}
+
+
+static void
+aux_get_win_position(afi, cb_data)
+    register AuxFrameInfo		*afi;
+    XIMLookupStartCallbackStruct        *cb_data;
+{
+    Display	*dpy;
+    Rect	*rect;
+
+    
+ /** overall window geometry **/
+#ifdef  GET_EVENT
+    dpy = afi->dpy;
+
+    afi->sc_width = DisplayWidth(dpy, DefaultScreen(dpy));
+    afi->sc_height = DisplayHeight(dpy, DefaultScreen(dpy));
+
+    rect = (Rect *) xv_get(afi->p_frame, WIN_RECT);
+
+    /* 
+     * Position aux frame relative to the parent frame
+     */
+    afi->f_x = rect->r_left + aux_defaults.window_off_x;
+    afi->f_y = rect->r_top + aux_defaults.window_off_y;
+
+#else
+    info->sc_x = DisplayWidth(info->dpy, DefaultScreen(info->dpy));
+    info->sc_y = DisplayHeight(info->dpy, DefaultScreen(info->dpy));
+    info->f_x = 100;
+    info->f_y = 100;
+#endif   
+}
+
+void
+aux_unpin_proc(frame)
+   Frame		frame;
+{
+
+	notice_prompt(frame, NULL,
+        	NOTICE_MESSAGE_STRING,
+                XV_MSG("You are in conversion mode.\n\
+Auxialiary Region window cannot be dismissed."),
+                NOTICE_BUTTON, XV_MSG("Continue"),
+                NULL);
+
+}
+
+
+/*
+ * This function retrieves user-preference setings from resource
+ * database.
+ */
+static void
+aux_get_defaults(locale)
+    Attr_attribute      locale;
+{
+        
+    defaults_set_locale(NULL, locale);
+ 
+    aux_defaults.keygrab = defaults_get_boolean("aux.keygrab",
+                                                "Aux.Keygrab",
+                                                TRUE);
+ 
+    aux_defaults.threed = defaults_get_boolean("OpenWindows.3DLook.Color",
+                                            
+                                               "OpenWindows.3DLook.Color",
+                                               TRUE);
+ 
+    if ((aux_defaults.font_name = defaults_get_string("aux.font",
+                                                      "Aux.Font",
+                                                      NULL)) != NULL)
+        aux_defaults.font_name = xv_strsave(aux_defaults.font_name);
+ 
+ 
+/*
+    aux_defaults.window_margin_x
+                = defaults_get_integer_check("aux.window.margin.x",
+                                             "Aux.Window.Margin.X",
+                                             15, 0, 100000);
+    aux_defaults.window_margin_y
+                = defaults_get_integer_check("aux.window.margin.y",
+                                             "Aux.Window.Margin.Y",
+                                             15, 0, 100000);
+*/
+    /* 
+     * Horizontal and vertical offset of aux region window from
+     * base window.
+     */
+    aux_defaults.window_off_x
+                = defaults_get_integer_check("aux.window.off.x",
+                                             "Aux.Window.Off.X",
+                                             20, 0, 100000);
+    aux_defaults.window_off_y
+                = defaults_get_integer_check("aux.window.off.y",
+                                             "Aux.Window.Off.Y",
+                                             10, 0, 100000);
+/*
+    aux_defaults.window_width
+                = defaults_get_integer_check("aux.window.width",
+                                             "Aux.Window.width",
+                                             20, 0, 100000);
+    aux_defaults.window_height
+                = defaults_get_integer_check("aux.window.height",
+                                             "Aux.Window.height",
+                                             10, 0, 100000);
+*/
+    /* 
+     * If true, aux region will try to fit within the screen 
+     */
+    aux_defaults.window_should_fit
+                = defaults_get_boolean("aux.window.fit",
+                                       "Aux.Window.Fit", TRUE);
+
+    /* 
+     * Horizontal and vertical screen margin used when 
+     * aux_defaults.window_should_fit is TRUE.
+     */
+    aux_defaults.screen_margin_x
+                = defaults_get_integer_check("aux.screen.margin.x",
+                                             "Aux.Screen.Margin.X",
+                                             20, 0, 100000);
+    aux_defaults.screen_margin_y
+                = defaults_get_integer_check("aux.screen.margin.y",
+                                             "Aux.Screen.Margin.Y",
+                                             20, 0, 100000);
+ 
+    defaults_set_locale(NULL, XV_NULL);
+}
+
+/*
+ *       This function sets geometry of AUX window.
+ */
+static
+aux_get_draw_info(info)
+    register AuxInfo    *info;
+{
+    AuxFrameInfo        *afi;
+    Rect		*rect;
+
+
+    afi = info->frame_info;
+
+    rect = (Rect *)xv_get(afi->frame, WIN_RECT);
+    afi->f_x = rect->r_left;
+    afi->f_y = rect->r_top;
+    afi->f_width = rect->r_width;
+    afi->f_height = rect->r_height;
+    /*   
+     * Now, make sure new window fits into the screen.
+     */
+    if (aux_defaults.window_should_fit) {
+    	if ((afi->f_width + afi->f_x)
+             > (afi->sc_width - aux_defaults.screen_margin_x))
+            afi->f_x = afi->sc_width - afi->f_width
+                        - aux_defaults.screen_margin_x;
+    	if (afi->f_x < aux_defaults.screen_margin_x)
+            afi->f_x = aux_defaults.screen_margin_x;
+ 
+        if ((afi->f_height + afi->f_y)
+             > (afi->sc_height - aux_defaults.screen_margin_y))
+            afi->f_y = afi->sc_height - afi->f_height
+                        - aux_defaults.screen_margin_y;
+    	if (afi->f_y < aux_defaults.screen_margin_y)
+            afi->f_y = aux_defaults.screen_margin_y;
+    }
+ 
+    return 0;
+}
--- origsrc/xview-3.2p1.4/lib/libxview/imcb/xaux.h	1970-01-01 01:00:00.000000000 +0100
+++ src/xview-3.2p1.4/lib/libxview/imcb/xaux.h	2013-02-23 14:44:38.453125000 +0000
@@ -0,0 +1,88 @@
+/*      "@(#)aux.h 50.9 93/06/28"		 */
+
+/*
+ *      (c) Copyright 1989 Sun Microsystems, Inc. Sun design patents 
+ *      pending in the U.S. and foreign countries. See LEGAL NOTICE 
+ *      file for terms of the license.
+ */
+
+#ifndef	aux_DEFINED
+#define	aux_DEFINED
+
+#define	AUX_UDATA_INFO(udata)	((AuxInfo *)(*(Xv_opaque *)udata))
+#define	AUX_KEY_DATA		101
+
+/*
+ * Frame info for the auxiliary region, aux will share the frame per base 
+ * frame basis.
+ */
+typedef struct _aux_frame_info {
+    Display                *dpy;
+    int                    sc_width;      /* screen width */
+    int                    sc_height;     /* screen hight */
+ 
+    Xv_object              p_obj;
+    Frame                  p_frame;       /* Parent frame */
+ 
+    Frame                  frame;
+    XID                    f_xwin;
+    int                    f_x;           /* frame position */
+    int                    f_y;
+    int                    f_width;       /* frame size */
+    int                    f_height;
+ 
+    Xv_Font                xv_font;       /* font in AUX */
+    XID                    afont;         /* ASCII font */
+    int                    achar_width;
+ 
+    XFontSet               font_set;
+    int                    char_ascent;
+    int                    char_descent;
+    int                    char_width;
+    int                    char_height;
+ 
+    Panel                  panel;
+    Panel_item             panel_item;
+ 
+    struct _aux_frame_info *next;
+} AuxFrameInfo;
+
+typedef struct _aux_default {
+    Bool                 has_been_initialized;
+ 
+    Bool                 keygrab;
+    Bool                 threed;
+    char                *font_name;
+ 
+    int                  window_margin_x;
+    int                  window_margin_y;
+    Bool                 window_should_fit;     /*
+                                                 * aux window will fit
+                                                 * within the screen.
+                                                 */
+    int                  window_off_x;  /* Offset from parent window */
+    int                  window_off_y;
+    int                  screen_margin_x;
+    int                  screen_margin_y;
+ 
+} AuxDefaults;
+	
+typedef	struct _aux_info {
+	Display				*dpy;
+	XIC				ic;
+	Bool				state;
+	Frame				frame;
+	Panel				panel;
+	Panel_item			item;
+	Xv_object			p_obj;
+        Frame				p_frame;
+
+	XIMPreeditDrawCallbackStruct	*pe_cache;
+	AuxFrameInfo			*frame_info;
+	int				f_x;
+	int				f_y;
+	int				f_width;
+	int				f_height;
+}  AuxInfo;
+
+#endif		/* ~aux_DEFINED */
--- origsrc/xview-3.2p1.4/lib/libxview/misc/expandname.c	2013-02-23 14:43:41.109375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/misc/expandname.c	2013-02-23 14:44:38.453125000 +0000
@@ -29,7 +29,7 @@ static char     sccsid[] = "@(#)expandna
 #include <vfork.h>
 #endif /* SVR4 */
 #endif
-#ifdef __linux__
+#if defined(__linux__) || defined(__CYGWIN__)
 #include <unistd.h>
 #endif
 
--- origsrc/xview-3.2p1.4/lib/libxview/misc/getlogindr.c	2013-02-23 14:43:41.015625000 +0000
+++ src/xview-3.2p1.4/lib/libxview/misc/getlogindr.c	2013-02-23 14:44:38.453125000 +0000
@@ -24,7 +24,7 @@ char           *
 xv_getlogindir()
 {
     extern char    *getlogin(), *getenv();
-#ifndef __linux__
+#if defined(__linux__) || defined(__CYGWIN__)
     extern struct passwd *getpwnam(), *getpwuid();
 #endif
     struct passwd  *passwdent;
--- origsrc/xview-3.2p1.4/lib/libxview/misc/gettext.c	2013-02-23 14:43:41.109375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/misc/gettext.c	2013-02-23 14:44:38.453125000 +0000
@@ -13,7 +13,7 @@ static char     sccsid[] = "@(#)gettext.
 char * dgettext(char *, char *), *bindtextdomain();
 static char *_gettext();
 char *fgets(), *getenv();
-#if !defined(__linux__) || !defined(__GLIBC__)
+#if (!defined(__linux__) || !defined(__GLIBC__)) && !defined(__CYGWIN__)
 caddr_t mmap();
 #endif
 
--- origsrc/xview-3.2p1.4/lib/libxview/misc/gettext.h	2013-02-23 14:43:41.109375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/misc/gettext.h	2013-02-23 14:44:38.453125000 +0000
@@ -1,7 +1,7 @@
 /* @(#)gettext.h 50.11 93/06/28 SMI */
 
 #define DEFAULT_DOMAIN	"default"
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 #define DEFAULT_BINDING "/usr/lib/locale\n"
 #else
 #define DEFAULT_BINDING "/usr/openwin/lib/locale\n"
@@ -17,7 +17,7 @@
 #include <errno.h>
 #ifdef OS_HAS_LOCALE
 #include <locale.h>
-#if defined(__linux__) && !defined(LC_MESSAGES) && defined(LC_RESPONSE)
+#if (defined(__linux__) || defined(__CYGWIN__)) && !defined(LC_MESSAGES) && defined(LC_RESPONSE)
 #define LC_MESSAGES LC_RESPONSE
 #endif
 #endif /* OS_HAS_LOCALE */
--- origsrc/xview-3.2p1.4/lib/libxview/misc/i18n_impl.h	2013-02-23 14:43:41.109375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/misc/i18n_impl.h	2013-02-23 14:44:38.453125000 +0000
@@ -26,7 +26,7 @@
 #include  <locale.h>
 
 /* Linux: gcc 2.4.x does not have LC_MESSAGES, but it has LC_RESPONSE instead */
-#if defined(__linux__) && !defined(LC_MESSAGES) && defined(LC_RESPONSE)
+#if (defined(__linux__) || defined(__CYGWIN__)) && !defined(LC_MESSAGES) && defined(LC_RESPONSE)
 #define LC_MESSAGES LC_RESPONSE
 #endif
 
--- origsrc/xview-3.2p1.4/lib/libxview/misc/portable.h	2013-02-23 14:43:40.953125000 +0000
+++ src/xview-3.2p1.4/lib/libxview/misc/portable.h	2013-02-23 14:44:38.453125000 +0000
@@ -49,7 +49,7 @@ EXTERN_FUNCTION (Attr_avlist copy_va_to_
 #define const
 #endif
 
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
 #define XV_BCOPY(a,b,c) memmove(b,a,c)
 #define XV_BZERO(a,b) memset(a,0,b)
 #define XV_INDEX(a,b) strchr(a,b)
@@ -66,17 +66,17 @@ EXTERN_FUNCTION (Attr_avlist copy_va_to_
  * Defines governing tty mode and pty behavior.  (These are relevant to the
  * ttysw code.)
  */
-#ifdef __linux__
-#define	XV_USE_TERMIOS
-#undef	XV_USE_SVR4_PTYS
+#if defined __linux__ || defined __CYGWIN__
+#define XV_USE_TERMIOS
+#undef  XV_USE_SVR4_PTYS
 #else
-#ifdef	SVR4
-#define	XV_USE_TERMIOS
-#define	XV_USE_SVR4_PTYS
-#else	/* SVR4 */
-#undef	XV_USE_TERMIOS
-#undef	XV_USE_SVR4_PTYS
-#endif	/* SVR4 */
+#ifdef  SVR4
+#define XV_USE_TERMIOS
+#define XV_USE_SVR4_PTYS
+#else   /* SVR4 */
+#undef  XV_USE_TERMIOS
+#undef  XV_USE_SVR4_PTYS
+#endif  /* SVR4 */
 #endif  /* __linux__ */
 
 #endif /* xview_portable_h_DEFINED */
--- origsrc/xview-3.2p1.4/lib/libxview/notice/notice_pt.c	2013-02-23 14:43:42.156250000 +0000
+++ src/xview-3.2p1.4/lib/libxview/notice/notice_pt.c	2013-02-23 14:44:38.468750000 +0000
@@ -29,7 +29,7 @@ Xv_public char xv_iso_select;
 /*
  * Table containing valid values for OpenWindows.KeyboardCommands resource
  */
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 Xv_private_data Defaults_pairs xv_kbd_cmds_value_pairs[4];
 #else
 /* Global already defined and initialized in server/server.c */
--- origsrc/xview-3.2p1.4/lib/libxview/notify/linux_select.c	2013-02-23 14:43:38.437500000 +0000
+++ src/xview-3.2p1.4/lib/libxview/notify/linux_select.c	2013-02-23 14:44:38.531250000 +0000
@@ -1,4 +1,4 @@
-#ifdef __linux__
+#if defined(__linux__) || defined(__CYGWIN__)
 
 
 /* Function for calling the select(2) system call in linux.
@@ -22,16 +22,17 @@
 #include <unistd.h>
                      
 #ifndef __GLIBC__
+#ifndef __CYGWIN__
 /* #define __LIBRARY__ */
 #include <syscall.h>
 /* #undef __LIBRARY__ */
-
+#endif
 #ifdef DEBUG
 #include <stdio.h>
 #endif
 #endif
 
-#ifdef __GLIBC__
+#if defined __GLIBC__ || defined __CYGWIN__
 
 int linux_select(int width, fd_set *readfds, fd_set *writefds,
                  fd_set *exceptfds, struct timeval *timeout) {
@@ -40,7 +41,11 @@ int linux_select(int width, fd_set *read
   if (timeout != NULL) {
     tout_copy = *timeout;
   }
+#ifndef __CYGWIN__
   return __select(width, readfds, writefds, exceptfds, timeout ? &tout_copy : NULL);
+#else
+  return _select(width, readfds, writefds, exceptfds, timeout ? &tout_copy : NULL);
+#endif
 }
 
 #else /* __GLIBC__ */
--- origsrc/xview-3.2p1.4/lib/libxview/notify/linux_select.h	2013-02-23 14:43:38.437500000 +0000
+++ src/xview-3.2p1.4/lib/libxview/notify/linux_select.h	2013-02-23 14:44:38.531250000 +0000
@@ -2,7 +2,7 @@
  * called through syscall() in XView. We don't use syscall,
  * but the unistd.h macros in the kernel sources. */
 
-#if defined(__linux__) && !defined(__LINUX_SELECT_H)
+#if (defined(__linux__)||defined(__CYGWIN__)) && !defined(__LINUX_SELECT_H)
 #define __LINUX_SELECT_H
 
 #include <unistd.h>
--- origsrc/xview-3.2p1.4/lib/libxview/notify/ndet_auto.c	2013-02-23 14:43:38.609375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/notify/ndet_auto.c	2013-02-23 14:44:38.546875000 +0000
@@ -73,7 +73,7 @@ ndet_auto_sig_send(client, condition, co
 		/* Auto sig is async */);
     /* Sweep all conditions & send notifications (recursive enumeration) */
     switch (condition->data.signal) {
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 /* In linux SIGIO == SIGURG */
       case SIGIO:
 #endif
@@ -151,7 +151,7 @@ ndet_auto_sig_send(client, condition, co
 
 	    enum_send->wait3 = &wd;
 	    /* Look for as many children as have changed state */
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !(defined(__linux__)||defined(__cygwin))
 	    while ((wd.pid = wait3(&wd.status, WNOHANG | WUNTRACED,
 				   &wd.rusage)) > 0)
 #else
--- origsrc/xview-3.2p1.4/lib/libxview/notify/ndet_fcntl.c	2013-02-23 14:43:38.453125000 +0000
+++ src/xview-3.2p1.4/lib/libxview/notify/ndet_fcntl.c	2013-02-23 14:44:38.625000000 +0000
@@ -19,7 +19,7 @@ static char     sccsid[] = "@(#)ndet_fcn
 #include <xview_private/ndet.h>
 #include <signal.h>
 #include <fcntl.h>
-#ifdef SVR4
+#if defined SVR4 || __CYGWIN__
 #include <sys/file.h>
 #endif /* SVR4 */
 #ifdef __linux__
@@ -28,7 +28,7 @@ static char     sccsid[] = "@(#)ndet_fcn
 
 int
 #ifndef __linux__
-#ifdef SVR4
+#if defined SVR4 || __CYGWIN__
 xv_fcntl(fd, cmd, arg)
 #else
 fcntl(fd, cmd, arg)
--- origsrc/xview-3.2p1.4/lib/libxview/notify/ndet_loop.c	2013-02-23 14:43:38.359375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/notify/ndet_loop.c	2013-02-23 14:44:38.640625000 +0000
@@ -19,7 +19,7 @@ static char     sccsid[] = "@(#)ndet_loo
 #include <xview_private/ndet.h>
 #include <xview_private/nint.h>
 #include <xview_private/ndis.h>	/* For ndis_dispatch */
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 #ifndef SVR4
 #include <syscall.h>
 #else /* SVR4 */
@@ -59,7 +59,7 @@ extern NTFY_CNDTBL *ntfy_cndtbl[NTFY_LAS
 
 /* NOTE! This assumes NSIG is 32. Not very portable */
 /* ndet_prev_sigvec needs to start off at all zeros */
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
 pkg_private_data struct sigvec ndet_prev_sigvec[NSIG] = {
     {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0},
     {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0},
@@ -80,13 +80,13 @@ pkg_private int ndet_signal_catcher();
 pkg_private void ndet_signal_catcher();
 #endif
 
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
 pkg_private_data struct sigvec ndet_sigvec = {ndet_signal_catcher, 0, 0};
 static int      ndet_signal_code;
 static struct sigcontext *ndet_signal_context;
 #else /* SVR4 */
 pkg_private_data struct sigaction ndet_sigvec =
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 	{SA_RESTART, {ndet_signal_catcher}, {0}, {0,0}};
 #else
 	{ndet_signal_catcher,0,SA_RESTART,NULL}; /* handler,mask,flags,restorer */
@@ -233,7 +233,7 @@ notify_start()
 	     * select, not ON THE WAY into select).
 	     */
 #ifndef SVR4
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 	    nfds = syscall(SYS_select,
 			   FD_SETSIZE, &ibits, &obits, &ebits,
 		 (sigisempty(&ndet_sigs_received)) ? timer : &ndet_polling_tv);
@@ -414,7 +414,7 @@ ndet_fig_fd_change()
     FD_ZERO(&ndet_obits);
     FD_ZERO(&ndet_ebits);
     sigdelset( &ndet_sigs_auto, SIGIO );
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
     sigdelset( &ndet_sigs_auto, SIGURG );
 #endif
     /* Recompute all bits */
@@ -426,7 +426,7 @@ ndet_fig_fd_change()
 				    ndet_fd_change, NTFY_ENUM_DATA_NULL);
     /* Toggle notifier auto signal catching if situation changed */
     ndet_toggle_auto(&sigs_tmp, SIGIO);
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
     ndet_toggle_auto(&sigs_tmp, SIGURG);
 #endif
 }
@@ -522,7 +522,9 @@ ndet_update_virtual_itimer()
     enum_itimer.min_func = ndet_virtual_min;
     /* Virtual itimers are relative to current state of process itimer */
     n = getitimer(ITIMER_VIRTUAL, &current_itimer);	/* SYSTEM CALL */
+#ifndef __CYGWIN__ /* ignore on cygwin */
     ntfy_assert(n == 0, 3 /* Unexpected error: getitimer */);
+#endif
     enum_itimer.current_tv = current_itimer.it_value;
     /* enum_itimer.min_tv is initialized in ndet_update_itimer. */
     /*
@@ -596,7 +598,9 @@ ndet_update_itimer(enum_itimer)
     process_itimer.it_value = enum_itimer->min_tv;
     n = setitimer(enum_itimer->which, &process_itimer,	/* SYSTEM CALL */
 		  (struct itimerval *) 0);
+#ifndef __CYGWIN__ /* ignore on cygwin */
     ntfy_assert(n == 0, 5 /* Unexpected error: setitimer */);
+#endif
 }
 
 /*
@@ -732,7 +736,7 @@ ndet_fig_sig_change()
 		/*
 		 * Don't catch this signal, currently we are
 		 */
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
 		n = sigvec(sig, &ndet_prev_sigvec[sig],
 			   (struct sigvec *) 0);	/* SYSTEM CALL */
 		ntfy_assert(n == 0, 6 /* Unexpected error: sigvec */);
@@ -760,7 +764,7 @@ ndet_enable_sig(sig)
 	int             n;
 
 	/* Arrange to catch this signal, currently we are not */
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
 	n = sigvec(sig, &ndet_sigvec, &ndet_prev_sigvec[sig]);
 	/* SYSTEM CALL */
 	ntfy_assert(n == 0, 8 /* Unexpected error: sigvec */);
@@ -785,14 +789,14 @@ pkg_private void		/* Should be static bu
 ndet_signal_catcher(sig, code, scp)
     int             sig;
     int             code;
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
     struct sigcontext *scp;
 #else /* SVR4 */
     ucontext_t *scp;
 #endif /* SVR4 */
 {
 
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
     void        (*old_handler) () = ndet_prev_sigvec[sig].sa_handler;
 #else
     void        (*old_handler) () = ndet_prev_sigvec[sig].sv_handler;
--- origsrc/xview-3.2p1.4/lib/libxview/notify/ndet_read.c	1993-06-29 06:18:04.000000000 +0100
+++ src/xview-3.2p1.4/lib/libxview/notify/ndet_read.c	2013-02-23 14:44:38.640625000 +0000
@@ -30,7 +30,7 @@ static int      ndet_read_done;
 static Notify_client ndet_read_nclient = (Notify_client) & ndet_read_done;
 
 extern int
-read(fd, buf, nbytes)
+ndet_read(fd, buf, nbytes)
     register int    fd;
     char           *buf;
     int             nbytes;
@@ -50,7 +50,7 @@ read(fd, buf, nbytes)
 	((ndet_clients == NTFY_CLIENT_NULL) &&
          (ndis_clients == NTFY_CLIENT_NULL)) ||
         (fd == notify_exclude_fd))
-	return (notify_read(fd, buf, nbytes));
+       return (notify_read(fd, buf, nbytes));
     /* Set up read condition */
     if (notify_set_input_func(ndet_read_nclient, ndet_read_in_func, fd) ==
 	NOTIFY_FUNC_NULL && notify_errno == NOTIFY_BADF) {
--- origsrc/xview-3.2p1.4/lib/libxview/notify/ndis_d_pri.c	2013-02-23 14:43:38.937500000 +0000
+++ src/xview-3.2p1.4/lib/libxview/notify/ndis_d_pri.c	2013-02-23 14:44:38.640625000 +0000
@@ -16,7 +16,7 @@ static char     sccsid[] = "@(#)ndis_d_p
 #include <xview_private/ntfy.h>
 #include <xview_private/ndis.h>
 #include <signal.h>
-#ifdef __linux__
+#if defined(__linux__) || defined(__cygwin)
 #include <sys/param.h> /* for howmany(), NBBY */
 #ifndef NBBY
 #define NBBY 8
--- origsrc/xview-3.2p1.4/lib/libxview/notify/ndisd_wait.c	2013-02-23 14:43:38.437500000 +0000
+++ src/xview-3.2p1.4/lib/libxview/notify/ndisd_wait.c	2013-02-23 14:44:38.640625000 +0000
@@ -22,7 +22,7 @@ extern          Notify_value
 notify_default_wait3(client, pid, status, rusage)
     Notify_client   client;
     int             pid;
-#ifndef SVR4
+#if !defined SVR4 && !defined __CYGWIN__
     union wait     *status;
 #else /* SVR4 */
     int *status;
--- origsrc/xview-3.2p1.4/lib/libxview/notify/nintn_wait.c	2013-02-23 14:43:38.609375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/notify/nintn_wait.c	2013-02-23 14:44:38.640625000 +0000
@@ -22,7 +22,7 @@ extern          Notify_value
 notify_next_wait3_func(nclient, pid, status, rusage)
     Notify_client   nclient;
     int             pid;
-#ifndef SVR4
+#if !defined SVR4 && !defined __CYGWIN__
     union wait     *status;
 #else /* SVR4 */
     int *status;
--- origsrc/xview-3.2p1.4/lib/libxview/notify/notify.h	2013-02-23 14:43:38.359375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/notify/notify.h	2013-02-23 14:44:38.640625000 +0000
@@ -23,7 +23,7 @@
 #include <sys/time.h>
 #include <sys/resource.h>
 #include <xview/base.h>
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 # ifdef SYSV_WAIT
 #  include <sys/rusage.h>
 # endif 
@@ -224,7 +224,7 @@ extern	struct itimerval NOTIFY_NO_ITIMER
 
 #ifndef _NOTIFY_MIN_SYMBOLS
 
-#ifdef SYSV_WAIT
+#if defined SYSV_WAIT || defined __CYGWIN__
 EXTERN_FUNCTION (Notify_value   notify_default_wait3, (Notify_client nclient, int pid, int  *status, struct rusage *rusage));
 #define notify_default_waitpid notify_default_wait3
 #else
@@ -310,7 +310,7 @@ EXTERN_FUNCTION (Notify_value 	notify_ne
 EXTERN_FUNCTION (Notify_value	notify_next_output_func, (Notify_client nclient, int fd));
 EXTERN_FUNCTION (Notify_value 	notify_next_signal_func, (Notify_client nclient, int signal, Notify_signal_mode mode));
 
-#ifdef SYSV_WAIT
+#if defined SYSV_WAIT || defined __CYGWIN__
 EXTERN_FUNCTION (Notify_value 	notify_next_wait3_func, (Notify_client nclient, int pid, int  *status, struct rusage *rusage));
 #define notify_next_waitpid_func notify_next_wait3_func
 #else
--- origsrc/xview-3.2p1.4/lib/libxview/notify/ntfy.h	2013-02-23 14:43:38.609375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/notify/ntfy.h	2013-02-23 14:44:38.640625000 +0000
@@ -15,7 +15,7 @@
 #ifndef	NTFY_DEFINED
 #define	NTFY_DEFINED
 
-#if defined(__linux__) && defined(__GLIBC__)
+#if (defined(__linux__)||defined(__CYGWIN__)) && defined(__GLIBC__)
 /* sigisemptyset gets prototyped in /usr/include/signal.h iff __USE_GNU is
  * defined. So we only prototype it ourselves if __USE_GNU isn't defined.
  * I'd prefer a cleaner solution, but I can't think of one at the moment :-(
@@ -167,7 +167,7 @@ typedef struct ntfy_condition {
  */
 typedef	struct ntfy_wait3_data {
 	int	pid;			/* Process waiting for */
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !(defined(__linux__) || defined(__CYGWIN__))
 	union	wait status;		/* Return value from wait3 */
 #else /* SVR4 */
 	int 	status;		/* Return value from wait3 */
@@ -202,7 +202,7 @@ extern	int ntfy_nodes_avail;	/* count of
 extern	sigset_t ntfy_sigs_delayed;/* Bit mask of signals received while in
 				      critical section */
 
-#if defined(__linux__) && defined(__GLIBC__)
+#if (defined(__linux__)||defined(__CYGWIN__)) && defined(__GLIBC__)
 /* martin.buck@bigfoot.com */
 #define sigisempty(s) sigisemptyset(s)
 #else
--- origsrc/xview-3.2p1.4/lib/libxview/notify/ntfy_fd_op.c	2013-02-23 14:43:38.875000000 +0000
+++ src/xview-3.2p1.4/lib/libxview/notify/ntfy_fd_op.c	2013-02-23 14:44:38.640625000 +0000
@@ -10,7 +10,7 @@ static char     sccsid[] = "@(#)ntfy_fd_
  *	file for terms of the license.
  */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(__CYGWIN__)
 #include <sys/time.h>
 #include <sys/param.h> /* for howmany() */
 #endif
--- origsrc/xview-3.2p1.4/lib/libxview/notify/sys_fcntl.c	2013-02-23 14:43:38.781250000 +0000
+++ src/xview-3.2p1.4/lib/libxview/notify/sys_fcntl.c	2013-02-23 14:44:38.656250000 +0000
@@ -15,7 +15,7 @@ static char     sccsid[] = "@(#)sys_fcnt
  */
 
 #ifndef SVR4
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 #include <syscall.h>
 #else
 #include "linux_select.h"
@@ -29,11 +29,13 @@ pkg_private int
 notify_fcntl(fd, cmd, arg)
     int             fd, cmd, arg;
 {
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
     return (syscall(SYS_fcntl, fd, cmd, arg));
 #else
 #ifdef __GLIBC__
     return (__fcntl(fd, cmd, arg));
+#elif defined __CYGWIN__
+    return (fcntl(fd, cmd, arg));
 #else
     return (sys_fcntl(fd, cmd, arg));
 #endif
--- origsrc/xview-3.2p1.4/lib/libxview/notify/sys_read.c	2013-02-23 14:43:38.515625000 +0000
+++ src/xview-3.2p1.4/lib/libxview/notify/sys_read.c	2013-02-23 14:44:38.718750000 +0000
@@ -15,7 +15,7 @@ static char     sccsid[] = "@(#)sys_read
  */
 
 #ifndef SVR4
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 #include <syscall.h>
 #else
 #include "linux_select.h"
@@ -31,11 +31,13 @@ notify_read(fd, buf, nbytes)
     char           *buf;
     int             nbytes;
 {
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
     return (syscall(SYS_read, fd, buf, nbytes));
 #else
 #ifdef __GLIBC__
     return (__read(fd, buf, (off_t)nbytes));
+#elif defined __CYGWIN__
+    return (read(fd, buf, (off_t)nbytes));
 #else
     return (sys_read(fd, buf, (off_t)nbytes));
 #endif
--- origsrc/xview-3.2p1.4/lib/libxview/notify/sys_select.c	2013-02-23 14:43:38.359375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/notify/sys_select.c	2013-02-23 14:44:38.718750000 +0000
@@ -15,7 +15,7 @@ static char     sccsid[] = "@(#)sys_sele
  */
 
 #ifndef SVR4
-#ifndef __linux__
+#if !defined __linux__ && !defined __CYGWIN__
 #include <syscall.h>
 #else
 #include "linux_select.h"
@@ -45,7 +45,7 @@ notify_select(nfds, readfds, writefds, e
 notify_select(nfds, in0, out0, ex0, tv)
 #endif /* SVR4 */
 #ifndef SVR4
-#ifndef __linux__
+#if !defined __linux__ && !defined __CYGWIN__
     int             nfds, *readfds, *writefds, *exceptfds;
 #else
     int             nfds;
@@ -57,9 +57,9 @@ notify_select(nfds, in0, out0, ex0, tv)
 #endif /* SVR4 */
     struct timeval *tv;
 {
-
+    
 #ifndef SVR4
-#ifndef __linux__
+#if !defined __linux__ && !defined __CYGWIN__
     nfds = syscall(SYS_select, nfds, readfds, writefds, exceptfds, tv);
     ntfy_assert(!(nfds == 0 && tv == (struct timeval *) 0 &&
 		  *readfds == 0 && *writefds == 0 && *exceptfds == 0), 39
--- origsrc/xview-3.2p1.4/lib/libxview/openwin/ow_view.c	2013-02-23 14:43:42.484375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/openwin/ow_view.c	2013-02-23 14:44:38.718750000 +0000
@@ -106,7 +106,7 @@ openwin_destroy_views(owin)
  * called from anywhere. openwin_check_view() is made redundant at the same
  * time. Is this a xview bug or can these routines be removed altogether??
  * Change static to Pkg_private on linux, for now. */
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 static int
 #else
 Pkg_private int
--- origsrc/xview-3.2p1.4/lib/libxview/panel/p_gauge.c	2013-02-23 14:43:40.437500000 +0000
+++ src/xview-3.2p1.4/lib/libxview/panel/p_gauge.c	2013-02-23 14:44:44.062500000 +0000
@@ -92,7 +92,7 @@ typedef struct {	/* data for a gauge */
     unsigned int vertical:1;
 } Gauge_info;
 
-static int etoi();
+static int etoi_gauge();
 
 
 /* ========================================================================= */
@@ -330,7 +330,7 @@ gauge_set_avlist(item_public, avlist)
 	    dp->value = dp->min_value;
 	else if (dp->value > dp->max_value)
 	    dp->value = dp->max_value;
-	dp->actual = etoi(dp, dp->value);
+	dp->actual = etoi_gauge(dp, dp->value);
     }
     if (size_changed || end_create)
 	update_rects(ip);
@@ -537,7 +537,7 @@ gauge_layout(item_public, deltas)
  * Convert external value (client units) to internal value (pixels).
  */
 static int
-etoi(dp, value)
+etoi_gauge(dp, value)
     Gauge_info    *dp;
     int             value;
 {
--- origsrc/xview-3.2p1.4/lib/libxview/panel/p_slider.c	2013-02-23 14:43:40.203125000 +0000
+++ src/xview-3.2p1.4/lib/libxview/panel/p_slider.c	2013-02-23 14:44:44.078125000 +0000
@@ -54,7 +54,7 @@ static void	check_endbox_entered();
 static Panel_setting get_value();
 static void     paint_slider();
 static void     update_rects();
-static int	etoi();
+static int	etoi_slider();
 static int	itoe();
 
 static Panel_ops ops = {
@@ -566,7 +566,7 @@ slider_set_avlist(item_public, avlist)
 	    value = dp->min_value;
 	else if (value > dp->max_value)
 	    value = dp->max_value;
-	dp->apparent = dp->actual = etoi(dp, value);
+	dp->apparent = dp->actual = etoi_slider(dp, value);
 	dp->print_value = value;
 	dp->use_print_value = TRUE;
     }
@@ -1324,7 +1324,7 @@ adjust_slider(ip, event, adjustment)
 	else if (dp->print_value > dp->max_value)
 	    dp->print_value = dp->max_value;
 	dp->use_print_value = TRUE;
-	dp->apparent = dp->actual = etoi(dp, dp->print_value);  /* in pixels */
+	dp->apparent = dp->actual = etoi_slider(dp, dp->print_value);  /* in pixels */
 	paint_slider(ip, OLGX_UPDATE); /* paint slider & update dp->sliderbox */
 	if (dp->flags & SHOWVALUE) {
 	    SPRINTF(buf, "%d", dp->print_value);
@@ -1380,7 +1380,7 @@ check_endbox_entered(ip, event)
  * Convert external value (client units) to internal value (pixels).
  */
 static int
-etoi(dp, value)
+etoi_slider(dp, value)
     Slider_info    *dp;
     int             value;
 {
@@ -1422,7 +1422,7 @@ get_value(item_public, event)
 	xv_set(item_public, PANEL_VALUE, buf, 0);
 #endif /* OW_I18N */
     }
-    dp->apparent = dp->actual = etoi(dp, value);
+    dp->apparent = dp->actual = etoi_slider(dp, value);
     dp->use_print_value = TRUE;
     dp->print_value = value;
     paint_slider(ip, OLGX_UPDATE);
--- origsrc/xview-3.2p1.4/lib/libxview/panel/p_utl.c	2013-02-23 14:43:40.328125000 +0000
+++ src/xview-3.2p1.4/lib/libxview/panel/p_utl.c	2013-02-23 14:44:38.734375000 +0000
@@ -169,7 +169,7 @@ panel_make_image(font, dest, type_code,
             xv_free(image_string_wc(dest));
     }
 #else
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
     {
         if (image_string(dest))
             xv_free(image_string(dest));
@@ -197,7 +197,7 @@ panel_make_image(font, dest, type_code,
 	    value_str = "";
 	if (!(str = (char *) panel_strsave((u_char *) value_str)))
 	    return (size);
-#ifdef __linux__
+#if defined(__linux__) || defined(__CYGWIN__)
 /* XView bug: This routine sometimes used a value that was already freed,
  * leading to clobbered menu items. The problem is the 
  * 'xv_free(image_string(dest))' above. In some cases the new 'value' 
--- origsrc/xview-3.2p1.4/lib/libxview/panel/panel.c	2013-02-23 14:43:40.437500000 +0000
+++ src/xview-3.2p1.4/lib/libxview/panel/panel.c	2013-02-23 14:44:38.734375000 +0000
@@ -28,7 +28,7 @@ Pkg_private int panel_destroy();
 
 static int      panel_layout();
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 Xv_private_data Defaults_pairs xv_kbd_cmds_value_pairs[4];
 #else
 extern Defaults_pairs xv_kbd_cmds_value_pairs[4];
--- origsrc/xview-3.2p1.4/lib/libxview/panel/panel_impl.h	2013-02-23 14:43:40.421875000 +0000
+++ src/xview-3.2p1.4/lib/libxview/panel/panel_impl.h	2013-02-23 14:44:38.734375000 +0000
@@ -10,7 +10,7 @@
 #define panel_impl_defined
 
 #ifndef FILE
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
 #undef NULL
 #endif /* SVR4 */
 #include <stdio.h>
--- origsrc/xview-3.2p1.4/lib/libxview/scrollbar/sb.c	2013-02-23 14:43:39.375000000 +0000
+++ src/xview-3.2p1.4/lib/libxview/scrollbar/sb.c	2013-02-23 14:44:38.734375000 +0000
@@ -43,7 +43,7 @@ Attr_attribute  sb_join_view_menu_item_k
 
 Xv_private void	win_set_no_focus();
 Xv_private Graphics_info	*xv_init_olgx();
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 Xv_private_data Defaults_pairs xv_kbd_cmds_value_pairs[4];
 #else
 extern Defaults_pairs xv_kbd_cmds_value_pairs[4];
--- origsrc/xview-3.2p1.4/lib/libxview/sel/sel_agent.c	2013-02-23 14:43:41.609375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/sel/sel_agent.c	2013-02-23 14:44:38.734375000 +0000
@@ -36,7 +36,7 @@ static char     sccsid[] = "@(#)sel_agen
  * Ultrix
  */
 #include <xview_private/ultrix_cpt.h>
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
 #include <stdlib.h>
 #include <unistd.h>
 #endif /* SVR4 */
--- origsrc/xview-3.2p1.4/lib/libxview/sel/seln_impl.h	2013-02-23 14:43:41.515625000 +0000
+++ src/xview-3.2p1.4/lib/libxview/sel/seln_impl.h	2013-02-23 14:44:38.734375000 +0000
@@ -11,7 +11,7 @@
 
 #include <errno.h>
 #ifndef FILE
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
 #undef NULL
 #endif /* SVR4 */
 #include <stdio.h>
--- origsrc/xview-3.2p1.4/lib/libxview/selection/sel_impl.h	2013-02-23 14:43:40.515625000 +0000
+++ src/xview-3.2p1.4/lib/libxview/selection/sel_impl.h	2013-02-23 14:44:38.812500000 +0000
@@ -218,7 +218,7 @@ Xv_private int  xv_seln_handle_req();
 Xv_private void xv_sel_send_old_owner_sel_clear();
 Xv_private void xv_sel_set_compat_data();
 
-#if !defined(__linux__) || defined(__DEFINE_SEL_IMPL_VARS)
+#if !(defined(__linux__) || defined(__CYGWIN__)) || defined(__DEFINE_SEL_IMPL_VARS)
 XContext  selCtx;
 XContext  reqCtx;
 XContext  targetCtx;
--- origsrc/xview-3.2p1.4/lib/libxview/selection/sel_req.c	2013-02-23 14:43:40.437500000 +0000
+++ src/xview-3.2p1.4/lib/libxview/selection/sel_req.c	2013-02-23 14:44:38.812500000 +0000
@@ -17,7 +17,7 @@ static char     sccsid[] = "@(#)sel_req.
 #include <xview/notify.h>
 #include <sys/time.h>
 
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
 #include <stdlib.h> 
 #endif /* SVR4 */
 
--- origsrc/xview-3.2p1.4/lib/libxview/selection/selection.c	2013-02-23 14:43:40.531250000 +0000
+++ src/xview-3.2p1.4/lib/libxview/selection/selection.c	2013-02-23 14:44:38.812500000 +0000
@@ -10,12 +10,12 @@ static char     sccsid[] = "@(#)selectio
  *	file for terms of the license.
  */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(__CYGWIN__)
 /* Kludge to prevent multiple variables with same name */
 #define __DEFINE_SEL_IMPL_VARS
 #endif
 #include <xview_private/sel_impl.h>
-#ifdef __linux__
+#if defined(__linux__) || defined(__CYGWIN__)
 #undef __DEFINE_SEL_IMPL_VARS
 #endif
 #include <xview/window.h>
--- origsrc/xview-3.2p1.4/lib/libxview/server/server.c	2013-02-23 14:43:39.359375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/server/server.c	2013-02-23 14:44:38.828125000 +0000
@@ -106,7 +106,7 @@ extern char    		*getenv();
 Xv_private_data char 	*xv_shell_prompt;
 
 /* global default server parameters */
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 Xv_private_data Xv_Server xv_default_server;
 Xv_private_data Xv_Screen xv_default_screen;
 Xv_private_data Display *xv_default_display;
--- origsrc/xview-3.2p1.4/lib/libxview/server/svr_kmdata.h	2013-02-23 14:43:39.359375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/server/svr_kmdata.h	2013-02-23 14:44:38.890625000 +0000
@@ -14,7 +14,7 @@
 
 #define MAX_NBR_MAPPINGS 6
 
-#if defined(__linux__) && !defined(NULL)
+#if (defined(__linux__)||defined(__CYGWIN__)) && !defined(NULL)
 #define NULL 0
 #endif
 
--- origsrc/xview-3.2p1.4/lib/libxview/server/svr_x.c	2013-02-23 14:43:39.359375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/server/svr_x.c	2013-02-23 14:44:38.890625000 +0000
@@ -28,7 +28,7 @@ static char     sccsid[] = "@(#)svr_x.c
 #include <X11/keysym.h>
 
 extern Display *XOpenDisplay();
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 Xv_private_data Defaults_pairs xv_kbd_cmds_value_pairs[4];
 #else
 /* Global already defined and initialized in in server/server.c */
--- origsrc/xview-3.2p1.4/lib/libxview/textsw/ei_text.c	2013-02-23 14:43:42.062500000 +0000
+++ src/xview-3.2p1.4/lib/libxview/textsw/ei_text.c	2013-02-23 14:44:38.906250000 +0000
@@ -105,7 +105,7 @@ typedef ei_plain_text_object *Eipt_handl
 #ifdef OW_I18N
 #define ISCNTRL(c)		((c >= 0) && iswcntrl(c))
 #else
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 #define ISCNTRL(c)		((128 <= c && c <= 159) || (iscntrl(c)))
 #else
 /* Linux: Allow 8-bit chars (do not treat them as control chars) */
@@ -735,7 +735,7 @@ Rescan:
 	    }
 	    batch++;
 	} else {
-#ifdef __linux__
+#if defined(__linux__) || defined(__CYGWIN__)
 /* Problems with 8-bit characters: 'aring' (0xe5) causes coredump in textedit
  * because it's regarded as ISCNTRL(), leading to 'special_char 'getting a
  * value > 255, leading to out-of-bound access of tempPf->pf_char[c]. Fix
--- origsrc/xview-3.2p1.4/lib/libxview/textsw/es_file.c	2013-02-23 14:43:41.859375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/textsw/es_file.c	2013-02-23 14:44:38.968750000 +0000
@@ -85,7 +85,7 @@ static char     sccsid[] = "@(#)es_file.
 
 #include <string.h>
 #include <fcntl.h>
-#ifdef SVR4
+#if defined SVR4 || defined __CYGWIN__
 #include <stdlib.h>
 #include <dirent.h>
 #else
@@ -97,7 +97,7 @@ static char     sccsid[] = "@(#)es_file.
 #include <sys/stat.h>
 #include <sys/file.h>
 #include <stdio.h>
-#ifdef __linux__
+#if defined(__linux__) || defined(__CYGWIN__)
 #include <unistd.h>
 #endif
 #include <xview/pkg.h>
@@ -112,7 +112,7 @@ static char     sccsid[] = "@(#)es_file.
 #include <xview_private/txt_18impl.h>
 
 
-#if defined(__linux__) && defined(__GLIBC__)
+#if defined(__linux__) && defined(__GLIBC__) || defined(__CYGWIN__)
 /* martin.buck@bigfoot.com */
 #include <errno.h>
 #else
@@ -345,7 +345,7 @@ es_file_create(name, options, status)
     char            name[MAXNAMLEN];      
     (void) wcstombs(name, name_wc, MAXNAMLEN);
 #endif /* OW_I18N */
-#ifdef __linux__
+#if defined(__linux__) || defined(__CYGWIN__)
     long int maxlinks;
 #endif
 
@@ -383,11 +383,11 @@ es_file_create(name, options, status)
 
 #ifndef BACKUP_AT_HEAD_OF_LINK
     /* (2) Chase the symbolic link if 'name' is one. */
-#ifdef __linux__
+#if defined(__linux__) || defined(__CYGWIN__)
     maxlinks = pathconf(name, _PC_LINK_MAX);
 #endif
     for (temp_name = name, link_count = 0;
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 	 (link_count < MAXSYMLINKS) &&
 #else
 	 (link_count < maxlinks) &&
@@ -397,7 +397,7 @@ es_file_create(name, options, status)
 	 temp_name = true_name, link_count++) {
 	true_name[true_name_len] = '\0';
     }
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
     if (link_count == MAXSYMLINKS) {
 #else
     if (link_count == maxlinks) {
@@ -612,7 +612,7 @@ es_file_fill_buf(private, buf, first, la
 #ifdef OW_I18N
         if ((multibyte) || (private->options & ES_OPT_BACKUPFILE)) {
         /* Backup file or multibyte locale, read in without converting */
-            read_in = read(private->fd, buf->chars,
+            read_in = ndet_read(private->fd, buf->chars,
 		       (last_plus_one - first) * sizeof(CHAR)) / sizeof(CHAR);
         } else {
             /* special case for reading input file in single byte locale */
@@ -622,7 +622,7 @@ es_file_fill_buf(private, buf, first, la
             if ((last_plus_one - first) > ES_READ_BUF_LEN)  
                 temp_buf_ptr = (char *)malloc(last_plus_one - first + 1);
                 
-            read_in = read(private->fd, temp_buf_ptr, last_plus_one - first);
+            read_in = ndet_read(private->fd, temp_buf_ptr, last_plus_one - first);
             if (read_in > 0) {
                 temp_buf_ptr[read_in] = NULL;
                 _xv_mbstowcs(buf->chars,(unsigned char *)temp_buf_ptr, read_in);
@@ -632,7 +632,7 @@ es_file_fill_buf(private, buf, first, la
                 free(temp_buf_ptr);    
         }	       	
 #else /* OW_I18N */
-	read_in = read(private->fd, buf->chars, last_plus_one - first);
+	read_in = ndet_read(private->fd, buf->chars, last_plus_one - first);
 #endif /* OW_I18N */
 	if (read_in == -1 ||
 	    read_in != last_plus_one - first /* paranoia */ ) {
@@ -930,6 +930,7 @@ es_file_read(esh, count, buf, count_read
     register int    to_read, still_needed;
     es_file_buf     dummy_read_buf;
 
+
     /*
      * Client may request more bytes than are available, so count cannot be
      * trusted in the following code.
@@ -939,12 +940,13 @@ es_file_read(esh, count, buf, count_read
     for (still_needed = *count_read;
 	 still_needed > 0;
 	 still_needed -= to_read, pos += to_read) {
+
 	/*
 	 * Figure out where the next set of characters is coming from. The
 	 * write_buf has precedence over the read_buf in the tests so that
 	 * overlap range reads from the write_buf!
 	 */
-	if (BUF_CONTAINS_POS(&private->write_buf, pos)) {
+ 	if (BUF_CONTAINS_POS(&private->write_buf, pos)) {
 	    to_read = BUF_LAST_PLUS_ONE(&private->write_buf) - pos;
 	    if (to_read > still_needed)
 		to_read = still_needed;
--- origsrc/xview-3.2p1.4/lib/libxview/textsw/ev_edit.c	2013-02-23 14:43:42.046875000 +0000
+++ src/xview-3.2p1.4/lib/libxview/textsw/ev_edit.c	2013-02-23 14:44:38.968750000 +0000
@@ -502,7 +502,7 @@ ev_make_visible(view, position, lower_co
                delta, position, line_seq[top_of_lc].pos,
                view->line_table.last_plus_one, lower_context, auto_scroll_by);
 #endif
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 	delta = MIN(delta, position - line_seq[top_of_lc].pos);
 #endif
 	if (delta < 50 * view->line_table.last_plus_one
--- origsrc/xview-3.2p1.4/lib/libxview/textsw/txt_again.c	2013-02-23 14:43:42.062500000 +0000
+++ src/xview-3.2p1.4/lib/libxview/textsw/txt_again.c	2013-02-23 14:44:38.984375000 +0000
@@ -19,7 +19,7 @@ static char     sccsid[] = "@(#)txt_agai
 #include <xview_private/txt_impl.h>
 #include <xview_private/ev_impl.h>
 #include <xview_private/txt_18impl.h>
-#if defined SVR4 || defined __linux__
+#if defined SVR4 || defined __linux__ || defined __CYGWIN__
 #include <stdlib.h>
 #include <string.h>
 #endif /* SVR4 */
@@ -179,7 +179,7 @@ textsw_string_min_free(ptr_to_string, mi
  * Recording routines
  */
 
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 /* The textsw_printf as written created a FILE struct, and called
  * _doprnt() to format the text to an XView internal buffer. If I
  * understand this correctly, it's just a replacement for vsprintf.
@@ -645,7 +645,7 @@ textsw_record_trash_insert(textsw)
  * Replaying routines
  */
 
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 /* The textsw_scanf as written created a FILE struct, and called
  * _doscan() to do the scanning on the instring.
  * This depends heavily on the internal structure of FILE, and is not
--- origsrc/xview-3.2p1.4/lib/libxview/textsw/txt_attr.c	1993-06-29 06:17:49.000000000 +0100
+++ src/xview-3.2p1.4/lib/libxview/textsw/txt_attr.c	2013-02-23 14:44:38.984375000 +0000
@@ -19,7 +19,7 @@ static char     sccsid[] = "@(#)txt_attr
 #include <xview_private/primal.h>
 #include <xview_private/txt_impl.h>
 #include <xview_private/txt_18impl.h>
-#ifdef SVR4
+#if defined SVR4 || defined __CYGWIN__
 #include <dirent.h>
 #include <string.h>
 #else
--- origsrc/xview-3.2p1.4/lib/libxview/textsw/txt_e_menu.c	2013-02-23 14:43:42.156250000 +0000
+++ src/xview-3.2p1.4/lib/libxview/textsw/txt_e_menu.c	2013-02-23 14:44:44.140625000 +0000
@@ -75,7 +75,7 @@ static	int      walk_getmenu();
 static	int      free_argv();
 static	int      Nargs;
 static	char	*check_filename_locale();
-static		any_shell_meta(char *s);
+static		any_shell_meta_e_menu(char *s);
 
 extern int      EXTRASMENU_FILENAME_KEY;
 
@@ -561,7 +561,7 @@ textsw_string_to_argv(command_line)
     char          **new_argv;
     char           *arg_array[MAXARGS];
     char            scratch[MAXSTRLEN];
-    int             use_shell = any_shell_meta(command_line);
+    int             use_shell = any_shell_meta_e_menu(command_line);
 
     Nargs = 0;
 
@@ -647,7 +647,7 @@ textsw_save2str(s, t)
  * Are there any shell meta-characters in string s?
  */
 static
-any_shell_meta(s)
+any_shell_meta_e_menu(s)
     register char  *s;
 {
 
--- origsrc/xview-3.2p1.4/lib/libxview/textsw/txt_edit.c	2013-02-23 14:43:41.859375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/textsw/txt_edit.c	2013-02-23 14:44:38.984375000 +0000
@@ -28,7 +28,7 @@ static char     sccsid[] = "@(#)txt_edit
 #define UPDATE_SCROLLBAR(_delta, _old_length)\
 	((THRESHOLD * _delta) >= _old_length)
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 Xv_private_data char *xv_shell_prompt;
 #else
 /* Global already defined in server/server.c */
--- origsrc/xview-3.2p1.4/lib/libxview/textsw/txt_file.c	2013-02-23 14:43:42.015625000 +0000
+++ src/xview-3.2p1.4/lib/libxview/textsw/txt_file.c	2013-02-23 14:44:38.984375000 +0000
@@ -18,11 +18,11 @@ static char     sccsid[] = "@(#)txt_file
 #include <xview_private/txt_impl.h>
 #include <xview_private/ev_impl.h>
 #include <xview_private/txt_18impl.h>
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
 #include <dirent.h>
 #include <string.h>
 #include <unistd.h>
-#ifdef __linux__
+#if defined(__linux__) || defined(__CYGWIN__)
 #include <sys/types.h>
 #include <fcntl.h>
 #endif
@@ -47,13 +47,13 @@ static char     sccsid[] = "@(#)txt_file
 	if ((unsigned)(to_test) != 0) (flags) |= (flag);	\
 	else (flags) &= ~(flag)
 
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
 extern char    *getcwd();
 #else
 extern char    *getwd();
 #endif /* SVR4 */
 
-#if defined(__linux__) && defined(__GLIBC__)
+#if (defined(__linux__) && defined(__GLIBC__)) || defined(__CYGWIN__)
 /* martin.buck@bigfoot.com */
 #include <errno.h>
 #else
@@ -368,7 +368,7 @@ textsw_full_pathname(name)
     }
 
 #ifdef		OW_I18N
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
     if (getcwd(pathname_mb, MAXPATHLEN) == 0)
 #else
     if (getwd(pathname_mb) == 0)
@@ -378,7 +378,7 @@ textsw_full_pathname(name)
 
 #else		/* OW_I18N */
 
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
     if (getcwd(pathname, MAXPATHLEN) == 0)
 #else
     if (getwd(pathname) == 0)
@@ -939,14 +939,14 @@ textsw_get_from_fd(view, fd, print_error
 	wc_count = textsw_mbstowcs(buf_ws, buf, &temp_count);
 	if (temp_count != count) {
 	    /* re-read the incomplete mb character */
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
 	    new_pos = lseek(fd, temp_count - count, SEEK_CUR); 
 #else
 	    new_pos = lseek(fd, temp_count - count, L_INCR); 
 #endif
 	    if (new_pos == old_pos) {
 		/* Invalid char, so advance to next byte */
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
 		old_pos = lseek(fd, 1L, SEEK_CUR);
 #else
 		old_pos = lseek(fd, 1L, L_INCR);
--- origsrc/xview-3.2p1.4/lib/libxview/textsw/txt_filter.c	2013-02-23 14:43:42.046875000 +0000
+++ src/xview-3.2p1.4/lib/libxview/textsw/txt_filter.c	2013-02-23 14:44:38.984375000 +0000
@@ -17,7 +17,7 @@ static char     sccsid[] = "@(#)txt_filt
 #include <sys/types.h>
 #include <sys/file.h>
 #include <unistd.h>
-#ifdef SVR4
+#if defined SVR4 || defined __CYGWIN__
 #include <dirent.h>
 #else
 #include <sys/dir.h>
@@ -38,7 +38,7 @@ static char     sccsid[] = "@(#)txt_filt
 #include <vfork.h>
 #endif /* SVR4 */
 #endif
-#ifdef __linux__
+#if defined(__linux__) || defined(__CYGWIN__)
 #include <unistd.h>
 #endif
 #include <sys/errno.h>
@@ -908,7 +908,7 @@ start_filter(filter_argv, filter_input,
 #ifdef SVR4
     if (xv_fcntl(to_filter[OUTPUT], F_SETFL, FNDELAY) == -1)
 #else
-#if !defined(__linux__) || defined(FNDELAY)
+#if !(defined(__linux__)||defined(__CYGWIN__)) || defined(FNDELAY)
     if (fcntl(to_filter[OUTPUT], F_SETFL, FNDELAY) == -1)
 #else
     if (fcntl(to_filter[OUTPUT], F_SETFL, O_NONBLOCK) == -1)
@@ -919,7 +919,7 @@ start_filter(filter_argv, filter_input,
 #ifdef SVR4
     if (xv_fcntl(from_filter[INPUT], F_SETFL, FNDELAY) == -1)
 #else
-#if !defined(__linux__) || defined(FNDELAY)
+#if !(defined(__linux__)||defined(__CYGWIN__)) || defined(FNDELAY)
     if (fcntl(from_filter[INPUT], F_SETFL, FNDELAY) == -1)
 #else
     if (fcntl(from_filter[INPUT], F_SETFL, O_NONBLOCK) == -1)
--- origsrc/xview-3.2p1.4/lib/libxview/textsw/txt_incl.c	2013-02-23 14:43:41.953125000 +0000
+++ src/xview-3.2p1.4/lib/libxview/textsw/txt_incl.c	2013-02-23 14:44:39.000000000 +0000
@@ -30,7 +30,7 @@ static char     sccsid[] = "@(#)txt_incl
 #include <xview/win_screen.h>
 #include <xview/file_chsr.h>
 
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
 #include <unistd.h>
 #include <string.h>
 #endif /* SVR4 */
@@ -108,14 +108,14 @@ do_include_proc(folio, ie)
 
     /* if "cd" is not disabled and the "cd" dir is not the current dir */
 #ifdef OW_I18N
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
     (void) getcwd(curr_dir_mb, MAX_STR_LENGTH);
 #else
     (void) getwd(curr_dir_mb);
 #endif /* SVR4 */
     (void) mbstowcs(curr_dir, curr_dir_mb, MAX_STR_LENGTH);
 #else /* OW_I18N */
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
     (void) getcwd(curr_dir, MAX_STR_LENGTH);
 #else
     (void) getwd(curr_dir);
@@ -272,7 +272,7 @@ create_include_items(panel, view)
     include_string[0] = NULL;
     (void) textsw_get_selection(view, &dummy, &dummy, include_string,
 				MAX_STR_LENGTH);
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
  (void) getcwd(current_dir_include_string, MAX_STR_LENGTH);
 #else
   (void) getwd(current_dir_include_string);
@@ -384,14 +384,14 @@ include_cmd_proc(fc,path,file,client_dat
 
     /* if "cd" is not disabled and the "cd" dir is not the current dir */
 #ifdef OW_I18N
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
     (void) getcwd(curr_dir_mb, MAX_STR_LENGTH);
 #else
     (void) getwd(curr_dir_mb);
 #endif /* SVR4 */
     (void) mbstowcs(curr_dir, curr_dir_mb, MAX_STR_LENGTH);
 #else /* OW_I18N */
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
     (void) getcwd(curr_dir, MAX_STR_LENGTH);
 #else
     (void) getwd(curr_dir);
--- origsrc/xview-3.2p1.4/lib/libxview/textsw/txt_once.c	2013-02-23 14:43:41.859375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/textsw/txt_once.c	2013-02-23 14:44:39.062500000 +0000
@@ -44,7 +44,7 @@ static char	sccsid[] = "@(#)txt_once.c 2
 #ifdef OW_I18N
 #include <xview_private/draw_impl.h>
 #endif
-#ifdef SVR4
+#if defined SVR4 || __CYGWIN__
 #include <dirent.h>
 #else
 #include <sys/dir.h>
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/charscreen.h	2013-02-23 14:43:39.765625000 +0000
+++ src/xview-3.2p1.4/lib/libxview/ttysw/charscreen.h	2013-02-23 14:44:39.140625000 +0000
@@ -23,7 +23,7 @@
  * Character dimensions (fixed width fonts only!)
  * and of screen in pixels.
  */
-#if !defined(__linux__) || defined(__DEFINE_CHARSCREEN_VARS)
+#if !(defined(__linux__) || defined(__CYGWIN__)) || defined(__DEFINE_CHARSCREEN_VARS)
 int	chrheight, chrwidth, chrbase;
 int	winheightp, winwidthp;
 int	chrleftmargin;
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/cim_size.c	1997-06-01 22:45:09.000000000 +0100
+++ src/xview-3.2p1.4/lib/libxview/ttysw/cim_size.c	2013-02-23 14:44:39.140625000 +0000
@@ -156,19 +156,35 @@ xv_tty_free_image_and_mode()
 {
 
     if (lines_ptr) {
+#ifndef __CYGWIN__
         cfree((CHAR *) (lines_ptr));
+#else
+        free((CHAR *) (lines_ptr));
+#endif
 	lines_ptr = NULL;
     }
     if (image) {
+#ifndef __CYGWIN__
         cfree((CHAR **) image);
+#else
+        free((CHAR **) image);
+#endif
 	image = NULL;
     }
     if (mode_ptr) {
+#ifndef __CYGWIN__
 	cfree((char *) (mode_ptr));
+#else
+        free((char *) (mode_ptr));
+#endif
 	mode_ptr = NULL;
     }
     if (screenmode) {
+#ifndef __CYGWIN__
 	cfree((char **) screenmode);
+#else
+        free((char **) screenmode);
+#endif
 	screenmode = NULL;
     }
 }
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/csr_change.c	2013-02-23 14:43:39.609375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/ttysw/csr_change.c	2013-02-23 14:44:39.140625000 +0000
@@ -44,7 +44,7 @@ static char     sccsid[] = "@(#)csr_chan
 #include <xview/attrol.h>
 #include <xview/server.h>
 #include <xview/font.h>
-#ifndef __linux__
+#if !defined __linux__&& !defined __CYGWIN__
 Xv_private_data char *xv_shell_prompt;
 #else
 /* Global already defined in server/server.c */
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/csr_init.c	2013-02-23 14:43:40.015625000 +0000
+++ src/xview-3.2p1.4/lib/libxview/ttysw/csr_init.c	2013-02-23 14:44:39.156250000 +0000
@@ -31,7 +31,7 @@ static char     sccsid[] = "@(#)csr_init
 #include <xview/window.h>
 #include <xview/font.h>
 #include <xview_private/charimage.h>
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 /* charscreen.h defines some variables, and then the header file is included
  * by more than one source file. The linux shlib-tools don't like it.
  * Kludge around it by setting a define here which makes the variable
@@ -39,7 +39,7 @@ static char     sccsid[] = "@(#)csr_init
 #define __DEFINE_CHARSCREEN_VARS
 #endif
 #include <xview_private/charscreen.h>
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 #undef __DEFINE_CHARSCREEN_VARS
 #endif
 #ifdef OW_I18N
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/term_impl.h	2013-02-23 14:43:39.703125000 +0000
+++ src/xview-3.2p1.4/lib/libxview/ttysw/term_impl.h	2013-02-23 14:44:39.218750000 +0000
@@ -238,7 +238,7 @@ Pkg_private int		tty_notice_key;
 #define	textsw_add_mark_i18n		textsw_add_mark_wc
 #define	textsw_erase_i18n		textsw_erase_wcs
 #define	textsw_delete_i18n		textsw_delete_wcs
-#else /OW_I18N */
+#else /* OW_I18N */
 #define	TEXTSW_LENGTH_I18N		TEXTSW_LENGTH
 #define	TEXTSW_CONTENTS_I18N		TEXTSW_CONTENTS
 #define	textsw_replace_i18n		textsw_replace_bytes
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/term_ntfy.c	2013-02-23 14:43:39.609375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/ttysw/term_ntfy.c	2013-02-23 14:44:39.218750000 +0000
@@ -22,7 +22,7 @@ static char     sccsid[] = "@(#)term_ntf
 #include <stdio.h>
 #include <ctype.h>
 #include <string.h>
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
 #include <unistd.h>
 #endif
 
@@ -63,7 +63,7 @@ Pkg_private void ttysw_print_debug_strin
 /* performance: global cache of getdtablesize() */
 extern int      dtablesize_cache;
 
-#if defined(SVR4) || defined(__linux__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
 #define GETDTABLESIZE() \
 (dtablesize_cache?dtablesize_cache:(dtablesize_cache=(int)sysconf(_SC_OPEN_MAX)))
 #else
@@ -173,7 +173,7 @@ ttysw_text_event(textsw, event, arg, typ
      * again, this is the place to start looking.
      */
     if (ttysw->pending_remote != ttysw->remote) {
-#if !defined(__linux__) || defined(TIOCREMOTE)
+#if !(defined(__linux__) || defined(__CYGWIN__)) || defined(TIOCREMOTE)
 	if (ioctl(ttysw->ttysw_pty, TIOCREMOTE, &ttysw->pending_remote) < 0)
 	    perror("ioctl: TIOCREMOTE");
 	else
@@ -202,7 +202,7 @@ ttysw_text_event(textsw, event, arg, typ
 	    /*
 	     * Process pending literal next insertion at end of buffer.
 	     */
-#ifndef __linux__
+#if !defined __linux__ && ! defined __CYGWIN__
 	    if (termsw->literal_next && action <= ASCII_LAST &&
 #else
 	    if (termsw->literal_next && action <= ISO_LAST &&
@@ -280,7 +280,7 @@ ttysw_text_event(textsw, event, arg, typ
 	 *	should get the same treatment.  For a third, whatever tests we
 	 *	make should also apply to the cooked_echo case.
 	 */
-#ifndef __linux__
+#if !defined __linux__ && ! defined __CYGWIN__
 	if (action == tty_getintrc(ttysw)) {
 	        (void) xv_set(textsw, TEXTSW_INSERTION_POINT_I18N,
 			  TEXTSW_INFINITY, 0);
@@ -301,7 +301,7 @@ ttysw_text_event(textsw, event, arg, typ
 					(Notify_event) (event), arg, type);
 	}
     } else if (!termsw->cooked_echo && down_event &&
-#ifndef __linux__
+#if !defined __linux__ && ! defined __CYGWIN__
 		action >= ASCII_FIRST && action <= ASCII_LAST) {
 #else
 		action >= ASCII_FIRST && action <= ISO_LAST) {
@@ -373,7 +373,7 @@ ttysw_text_event(textsw, event, arg, typ
 	* Even if cooked echo is off, we still have to handle
 	* keyboard signals.
 	*/
-#ifndef __linux__
+#if !defined __linux__ && ! defined __CYGWIN__
 	if (!termsw->cooked_echo && !tty_issig(ttysw))
 	    break;
 #else
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/termsw.c	2013-02-23 14:43:40.093750000 +0000
+++ src/xview-3.2p1.4/lib/libxview/ttysw/termsw.c	2013-02-23 14:44:39.218750000 +0000
@@ -418,7 +418,7 @@ termsw_folio_init_internal(parent, terms
 
     /* Set the PTY to operate as a "remote terminal". */
     fd = (int) xv_get(termsw_public, TTY_PTY_FD);
-#if !defined(__linux__) || defined(TIOCREMOTE)
+#if !(defined(__linux__) || defined(__CYGWIN__)) || defined(TIOCREMOTE)
     (void) ioctl(fd, TIOCREMOTE, &on);
 #endif
     ttysw_folio->remote = ttysw_folio->pending_remote = on;
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/tty.c	1993-06-29 06:17:12.000000000 +0100
+++ src/xview-3.2p1.4/lib/libxview/ttysw/tty.c	2013-02-23 14:44:39.234375000 +0000
@@ -530,11 +530,11 @@ ttysw_view_get(ttysw_view_public, status
 
 
 /* ARGSUSED */
-static
+static int
 tty_quit_on_death(client, pid, status, rusage)
     caddr_t         client;
     int             pid;
-#ifndef SVR4
+#if !defined SVR4 && !defined __CYGWIN__
     union wait     *status;
 #else
     int     *status;
@@ -546,7 +546,11 @@ tty_quit_on_death(client, pid, status, r
     Xv_object       frame;
 
     if (!(WIFSTOPPED(*status))) {
+#ifdef __CYGWIN__
+	if (WTERMSIG(*status) || WEXITSTATUS(*status)) {
+#else
 	if (WTERMSIG(*status) || WEXITSTATUS(*status) || WCOREDUMP(*status)) {
+#endif
 	    if (TTY_IS_TERMSW(ttysw))  {
 	        (void)fprintf(stderr, 
 		    XV_MSG("A command window has exited because its child exited.\n"));
@@ -567,12 +571,14 @@ tty_quit_on_death(client, pid, status, r
 			XV_MSG(" exited with return code %d"),
 			       WEXITSTATUS(*status));
 	    }
+#ifndef __CYGWIN__
 	    if (WCOREDUMP(*status)) {
 		(void) fprintf(stderr, 
 			XV_MSG(" and left a core dump.\n"));
 	    } else {
 		(void) fprintf(stderr, ".\n");
 	    }
+#endif
 	}
 	frame = xv_get(tty_public, WIN_FRAME);
 	(void) xv_set(frame, FRAME_NO_CONFIRM, TRUE, 0);
@@ -586,7 +592,7 @@ static
 tty_handle_death(tty_folio_private, pid, status, rusage)
     Ttysw_folio     tty_folio_private;
     int             pid;
-#ifndef SVR4
+#if !defined SVR4 && !defined __CYGWIN__
     union wait     *status;
 #else
     int     *status;
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/tty_gtty.c	2013-02-23 14:43:40.109375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/ttysw/tty_gtty.c	2013-02-23 14:44:39.234375000 +0000
@@ -34,7 +34,7 @@ static  char sccsid[] = "@(#)tty_gtty.c
  */
 #ifdef	XV_USE_TERMIOS
 
-#if defined(__linux__) && !defined(CINTR)
+#if (defined(__linux__)||defined(__CYGWIN__)) && !defined(CINTR)
 /* The following values have been obtained from /usr/include/linux/tty.h.
  * They represent the default tty modes on linux.
 	intr=^C		quit=^|		erase=del	kill=^U
@@ -61,9 +61,14 @@ static  char sccsid[] = "@(#)tty_gtty.c
 #define CWERASE 027
 #define CLNEXT 026
 #define CEOL2 0
+#elif defined __CYGWIN__
+#define CTIME 0
+#define CMIN 1
+#define CREPRINT 022
+#define CDISCARD 017
 #endif /* __linux__ && !CINTR */
 
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 /* martin.buck@bigfoot.com */
 #ifndef CSWTC
 #define CSWTC 0
@@ -279,7 +284,7 @@ we_getptyparms(tp)
     struct termios	*tp;
 {
     char	str[WE_TTYPARMSLEN];
-#ifndef __linux__
+#if !defined __linux__ && !defined __CYGWIN__
     short	temps[16];
 #else
     short	temps[17];
@@ -290,7 +295,7 @@ we_getptyparms(tp)
     else {
 	register int i;
 
-#ifndef __linux__
+#if !defined __linux__ && !defined __CYGWIN__
 	if (sscanf(str,
 		"%ld,%ld,%ld,%ld,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd",
 		&tp->c_iflag, &tp->c_oflag, &tp->c_cflag, &tp->c_lflag,
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/tty_impl.h	2013-02-23 14:43:39.953125000 +0000
+++ src/xview-3.2p1.4/lib/libxview/ttysw/tty_impl.h	2013-02-23 14:44:39.234375000 +0000
@@ -211,7 +211,7 @@ typedef Ttysw_view_object* 	Ttysw_view_h
  */
 #ifdef	XV_USE_TERMIOS
 #define	tty_gettabs(t)		((t)->termios.c_oflag & XTABS)
-#if !defined(__linux__) || defined(VDSUSP)
+#if !(defined(__linux__)||defined(__CYGWIN__)) || defined(VDSUSP)
 #define	tty_getdsuspc(t)	((int) ((t)->termios.c_cc[VDSUSP]))
 #else
 #define	tty_getdsuspc(t)	((int) -1)
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/tty_init.c	2013-02-23 14:43:39.781250000 +0000
+++ src/xview-3.2p1.4/lib/libxview/ttysw/tty_init.c	2013-02-23 14:44:44.140625000 +0000
@@ -22,6 +22,11 @@ static char     sccsid[] = "@(#)tty_init
 #include <signal.h>
 #include <string.h>
 
+#ifdef __CYGWIN__
+#include <unistd.h>
+#include <pty.h>
+#endif
+
 #include <xview_private/portable.h>	/* for XV* defines and termios */
 
 #ifdef	XV_USE_SVR4_PTYS
@@ -44,7 +49,7 @@ static char     sccsid[] = "@(#)tty_init
 #include <ctype.h>
 #include <fcntl.h>
 
-#if defined(__linux__) && defined(__GLIBC__)
+#if (defined(__linux__) && defined(__GLIBC__)) || defined(__CYGWIN__)
 /* martin.buck@bigfoot.com */
 #if __GLIBC__ == 2 && __GLIBC_MINOR__ == 0 
 #include <ioctls.h>
@@ -90,8 +95,9 @@ static char     sccsid[] = "@(#)tty_init
 #define jcsetpgrp(p)	setpgrp((p),(p))
 #endif
 
-
+#ifndef __CYGWIN__
 extern long     lseek();
+#endif
 char           *textsw_checkpoint_undo();
 
 /* static */ void ttysw_parseargs();
@@ -445,7 +451,7 @@ ttysw_add_FNDELAY(fd)
     if ((fdflags = fcntl(fd, F_GETFL, 0)) == -1)
 #endif
 	return (-1);
-#if !defined(__linux__) || defined(FNDELAY)
+#if !(defined(__linux__) || defined(__CYGWIN__)) || defined(FNDELAY)
     fdflags |= FNDELAY;
 #else
     fdflags |= O_NONBLOCK;
@@ -473,11 +479,12 @@ ttysw_fork_it(ttysw0, argv, wfd)
     char	    appname[20];
     char	    *p;
     unsigned        ttysw_error_sleep = 1;
-#if !defined(SVR4) && !defined(__linux__)
+
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
     struct sigvec   vec, ovec;
 #else
     struct sigaction	vec, ovec;
-#ifndef __linux__
+#if !defined __linux__ && !defined __CYGWIN__
     extern char *ptsname();
 #endif
 
@@ -488,6 +495,7 @@ ttysw_fork_it(ttysw0, argv, wfd)
 #endif
  
 #endif /* SVR4 */
+    
     ttysw->ttysw_pidchild = fork();
     if (ttysw->ttysw_pidchild < 0)	/* fork failed */
 	return (-1);
@@ -498,13 +506,13 @@ ttysw_fork_it(ttysw0, argv, wfd)
 	}
 
 #ifdef DEBUG
-	sleep(3);
+	//sleep(3);
 #endif				/* DEBUG */
 	return (ttysw->ttysw_pidchild);
     }
 
     /* Set up the child characteristics */
-#if !defined(SVR4) && !defined(__linux__)  	/* SunOS4.x code */
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__) 	/* SunOS4.x code */
     vec.sv_handler = SIG_DFL;
     vec.sv_mask = vec.sv_onstack = 0;
     sigvec(SIGWINCH, &vec, 0);
@@ -540,17 +548,18 @@ ttysw_fork_it(ttysw0, argv, wfd)
     vec.sa_flags = SA_RESTART;
     sigaction(SIGTTOU, &vec, &ovec);
 
-#ifndef __linux__
+#if !defined __linux__ && !defined __CYGWIN__
     if (unlockpt(ttysw->ttysw_pty) == -1)
         perror("unlockpt (2)");
     if ((ttysw->ttysw_tty = open(ptsname(ttysw->ttysw_pty),O_RDWR))<0)
         return -1;
 #else
     setpgrp();
-    if ((ttysw->ttysw_tty = open(ttysw->tty_name,O_RDWR))<0)
-        return -1;
+    if ((ttysw->ttysw_tty = open(ttysw->tty_name,O_RDWR ))<0)
+      return -1;
+    (void) close(ttysw->ttysw_tty);
 #endif
-
+    
     sigaction(SIGTTOU, &ovec, (struct sigaction *) 0);
 #endif /* SVR4 */
 
@@ -559,9 +568,10 @@ ttysw_fork_it(ttysw0, argv, wfd)
      * close-on-exec, and don't need any further cleanup.
      */
     (void) close(ttysw->ttysw_pty);
-#ifndef SVR4
-    ttysw->ttysw_tty = open(ttysw->tty_name, O_RDWR);  /* open /dev/ttyp* */
+#if !defined SVR4
+    ttysw->ttysw_tty = open(ttysw->tty_name, O_RDWR );  /* open /dev/ttyp* */
 #endif
+
     (void) dup2(ttysw->ttysw_tty, 0);
     (void) dup2(ttysw->ttysw_tty, 1);
     (void) dup2(ttysw->ttysw_tty, 2);
@@ -605,7 +615,6 @@ ttysw_fork_it(ttysw0, argv, wfd)
 #endif /* BSD_TTY_COMPAT */
 #endif /* SVR4 */
 
-
     /* restore various signals to their defaults */
     signal (SIGINT, SIG_DFL);
     signal (SIGQUIT, SIG_DFL);
@@ -650,7 +659,11 @@ ttysw_parseargs(opts, argcptr, argv_base
     /* Determine what shell to run. */
     shell = getenv("SHELL");
     if (!shell || !*shell)
+#ifndef __CYGWIN__
 	shell = "/bin/sh";
+#else
+	shell = "/bin/bash";
+#endif
     opts->args[0] = shell;
     /* Setup remainder of arguments */
     if (*argv == (char *) NULL) {
@@ -721,7 +734,7 @@ ttyinit(ttysw)
     int		    tmpfd;
     int		    pty = 0, tty = 0;
     int             on = 1;
-#ifdef __linux__
+#if defined(__linux__) || defined(__CYGWIN__)
     if (openpty(&pty, &tty, ttysw->tty_name, NULL, NULL) == -1) {
 	fprintf(stderr, XV_MSG("All pty's in use\n"));
 	return XV_ERROR;
@@ -918,7 +931,6 @@ gotpty:
 
 #endif /* SB_NO_DROPS */
 
-
     if (ioctl(pty, I_PUSH, "pckt") == -1) { /* must use getmsg for read */
         perror("push pckt");
 	return XV_ERROR;
@@ -990,7 +1002,7 @@ gotpty:
  */
 
 #ifndef SVR4
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 /*
  * Make entry in /etc/utmp for ttyfd. Note: this is dubious usage of
  * /etc/utmp but many programs (e.g. sccs) look there when determining who is
@@ -1138,4 +1150,3 @@ updateutmp(username, ttyslotuse, ttyfd)
 }
 #endif /* __linux__ */
 #endif /* SVR4 */
-
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/tty_main.c	2013-02-23 14:43:39.859375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/ttysw/tty_main.c	2013-02-23 14:44:39.234375000 +0000
@@ -65,7 +65,7 @@ static char     sccsid[] = "@(#)tty_main
 #endif /* FULL_R5 */    
 #endif
 
-#if defined(__linux__) && defined(__GLIBC__)
+#if (defined(__linux__) && defined(__GLIBC__)) || defined(__CYGWIN__)
 /* martin.buck@bigfoot.com */
 #include <sys/ioctl.h>
 #endif
@@ -400,7 +400,7 @@ ttysw_pty_output(ttysw, pty)
 	}
 	/* only write the rest of the buffer if it doesn't have an eot in it */
 	if (termsw->pty_eot > -1)
-	    return;
+	    return 0;
     }
     if (iwbp > irbp) {
 	/*
@@ -412,7 +412,7 @@ ttysw_pty_output(ttysw, pty)
 	 *	test never succeeds; we're just being paranoid here.
 	 */
 	if (!ttysw_pty_output_ok(ttysw))
-	    return;
+	    return 0;
 	cc = write(pty, irbp, iwbp - irbp);
 #ifdef DEBUG
 	printf("write to pty: ");
@@ -425,6 +425,7 @@ ttysw_pty_output(ttysw, pty)
 	} else if (cc < 0)
 	    perror(XV_MSG("TTYSW pty write failure"));
     }
+    return 0;
 }
 #endif
 
@@ -449,6 +450,7 @@ ttysw_process_STI(ttysw, cp, cc)
      * If we're not in remote mode, then the OS tty line discipline code will
      * already have handled the TIOCSTI, leaving us with nothing to do here.
      */
+
     if (!ttysw_getopt(ttysw, TTYOPT_TEXT))
 	return;
 
@@ -490,6 +492,7 @@ ttysw_process_STI(ttysw, cp, cc)
     }
     /* flush caches */
     (void) xv_get(textsw, TEXTSW_LENGTH_I18N);
+
 }
 
 
@@ -786,6 +789,7 @@ process_mb_buf:
 	    break;
 	  }
 
+#ifndef __CYGWIN__
 	case TIOCSTI:
 	    /*
 	     * The argument byte(s) for the TIOCSTI imediately follow the
@@ -794,6 +798,7 @@ process_mb_buf:
 	    ttysw_process_STI(ttysw, databuf.buf + sizeof *ioc,
 	        databuf.len - sizeof *ioc);
 	    break;
+#endif
 
 	default:
 	    /*
@@ -827,6 +832,8 @@ ttysw_pty_input(ttysw, pty)
     register int    cc;
     char            ucntl;
     register unsigned int_ucntl;
+
+
 #ifdef OW_I18N
 #define MB_BUF_SIZE     12
         register int    wc_nchar;       /* number of wide characters converted */
@@ -860,7 +867,9 @@ ttysw_pty_input(ttysw, pty)
         XV_BCOPY(rest_of_char, mb_buf_p, rest_of_nchar);
     iov[1].iov_base = (char *)mb_buf_p + rest_of_nchar; /* yuck */
 #endif
+
     cc = readv(pty, iov, 2);
+
 #ifdef OW_I18N
         mb_buf_p[cc - 1 + rest_of_nchar] = 0;
         {
@@ -909,6 +918,7 @@ ttysw_pty_input(ttysw, pty)
         if (mb_buf_p != mb_buf) {
                 free(mb_buf_p);
         }
+
 #endif
     if (cc < 0 && errno == EWOULDBLOCK)
 	cc = 0;
@@ -917,7 +927,7 @@ ttysw_pty_input(ttysw, pty)
     if (cc > 0) {
 	int_ucntl = (unsigned) ucntl;
 
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 	/* Under Linux, int_ucntl doesn't get set when enabling/disabling
 	 * ECHO mode. So we always have to read the current tty settings :-(
 	 * martin-2.buck@student.uni-ulm.de
@@ -926,10 +936,14 @@ ttysw_pty_input(ttysw, pty)
 #else
 	if (int_ucntl != 0 && ttysw_getopt(ttysw, TTYOPT_TEXT)) {
 #endif
+
+#ifndef __CYGWIN__
 	    unsigned        tiocsti = TIOCSTI;
 
 	    if (int_ucntl == (tiocsti & 0xff))
 		ttysw_process_STI(ttysw, owbp, cc - 1);
+#endif
+
 #ifndef XV_USE_TERMIOS
 	    (void) ioctl(ttysw->ttysw_tty, TIOCGETC, &ttysw->tchars);
 	    (void) ioctl(ttysw->ttysw_tty, TIOCGLTC, &ttysw->ltchars);
@@ -937,11 +951,11 @@ ttysw_pty_input(ttysw, pty)
             (void)tcgetattr(ttysw->ttysw_tty, &ttysw->termios);
 #endif
 	    ttysw_getp(TTY_VIEW_HANDLE_FROM_TTY_FOLIO(ttysw));	/* jcb for nng */
-#ifdef __linux__
-	}
+#if defined __linux__ 
+	} 
 	if (int_ucntl == 0)
 #else
-	} else
+	}
 #endif
 #ifdef OW_I18N
                 owbp += wc_nchar;
@@ -967,10 +981,11 @@ ttysw_consume_output(ttysw_view)
     int             cc;
 
     /* cache the cursor removal and re-render once in this set -- jcb */
-    if (is_not_text = !ttysw_getopt((caddr_t) ttysw, TTYOPT_TEXT)) {
+    if ((is_not_text = !ttysw_getopt((caddr_t) ttysw, TTYOPT_TEXT))) {
 	(void) ttysw_removeCursor();
 	do_cursor_draw = FALSE;
     }
+
     while (owbp > orbp && !(ttysw->ttysw_flags & TTYSW_FL_FROZEN)) {
 	if (is_not_text) {
 #ifdef OW_I18N
@@ -1527,7 +1542,7 @@ xv_tty_new_size(ttysw, cols, lines)
      */
 
     struct ttysize  ts;
-#ifndef SVR4
+#if !defined SVR4 && !defined __CYGWIN__
     struct sigvec vec, ovec;
  
     vec.sv_handler = SIG_IGN;
@@ -1540,7 +1555,7 @@ xv_tty_new_size(ttysw, cols, lines)
     if ((ioctl(ttysw->ttysw_tty, TIOCSSIZE, &ts)) == -1)
 	perror(XV_MSG("ttysw-TIOCSSIZE"));
 
-#ifndef SVR4
+#if !defined SVR4 && !defined __CYGWIN__
     (void) sigvec(SIGTTOU, &ovec, 0);
 #endif
 #else /* sun */
@@ -1548,7 +1563,7 @@ xv_tty_new_size(ttysw, cols, lines)
      * Otherwise, we use the winsize struct  and TIOCSWINSZ ioctl.
      */
     struct winsize  ws;
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
     struct sigvec vec, ovec;
 
     vec.sv_handler = SIG_IGN;
@@ -1561,7 +1576,7 @@ xv_tty_new_size(ttysw, cols, lines)
     if ((ioctl(ttysw->ttysw_tty, TIOCSWINSZ, &ws)) == -1)
 	perror(XV_MSG("ttysw-TIOCSWINSZ"));
 
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
     (void) sigvec(SIGTTOU, &ovec, 0);
 #endif
 #endif /* sun */
@@ -1661,7 +1676,7 @@ Pkg_private void
 ttysw_flush_input(ttysw)
     Ttysw_folio     ttysw;
 {
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
     struct sigvec   vec, ovec;	/* Sys V compatibility */
     int flushf = 0;
 
@@ -1692,7 +1707,7 @@ ttysw_flush_input(ttysw)
 #   endif /* XV_USE_TERMIOS */
 	perror(XV_MSG("TIOCFLUSH"));
 
-#if !defined(SVR4) && !defined(__linux__)
+#if !defined(SVR4) && !defined(__linux__) && !defined(__CYGWIN__)
     (void) sigvec(SIGTTOU, &ovec, (struct sigvec *) 0);
 #else
     sigaction(SIGTTOU, &ovec, (struct sigaction *) 0);
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/tty_mapkey.c	2013-02-23 14:43:39.609375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/ttysw/tty_mapkey.c	2013-02-23 14:44:39.234375000 +0000
@@ -12,7 +12,7 @@ static char     sccsid[] = "@(#)tty_mapk
 
 #include <stdio.h>
 #include <ctype.h>
-#if defined SVR4 || defined __linux__ 
+#if defined SVR4 || defined __linux__ || defined __CYGWIN__ 
 #include <string.h>
 #endif
 #include <unistd.h> /* for access(2) - mbuck@debian.org */
@@ -513,7 +513,7 @@ ttysw_remove_caps(label, label_ptr)
  * have more time.
  */
 
-#if defined(i386) && !defined(__linux__)
+#if defined(i386) && !defined(__linux__) && !defined(__CYGWIN__)
 static void
 ttysw_arrow_keys_to_string(xv_id, str)
     unsigned        xv_id;
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/tty_modes.c	2013-02-23 14:43:39.937500000 +0000
+++ src/xview-3.2p1.4/lib/libxview/ttysw/tty_modes.c	2013-02-23 14:44:39.312500000 +0000
@@ -125,7 +125,7 @@ ttysw_be_ttysw(ttysw_view)
 	/*
 	 * Switch the pty out of remote mode.
 	 */
-#if !defined(__linux__) || defined(TIOCREMOTE)
+#if !(defined(__linux__) || defined(__CYGWIN__)) || defined(TIOCREMOTE)
 	if (ioctl(ttysw->ttysw_pty, TIOCREMOTE, &off) < 0)
 	    perror("ioctl: TIOCREMOTE");
 	else
@@ -278,7 +278,7 @@ ttysw_be_termsw(ttysw_view)
      */
     ttysw_getp((Ttysw_view_handle) ttysw_view);
     ttysw->pending_remote = termsw->cooked_echo;
-#if !defined(__linux__) || defined(TIOCREMOTE)
+#if !(defined(__linux__) || defined(__CYGWIN__)) || defined(TIOCREMOTE)
     if (ioctl(ttysw->ttysw_pty, TIOCREMOTE, &ttysw->pending_remote) < 0)
 	perror("ioctl: TIOCREMOTE");
     else
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/tty_ntfy.c	2013-02-23 14:43:39.609375000 +0000
+++ src/xview-3.2p1.4/lib/libxview/ttysw/tty_ntfy.c	2013-02-23 14:44:39.312500000 +0000
@@ -44,7 +44,7 @@ static char     sccsid[] = "@(#)tty_ntfy
 #include <xview_private/term_impl.h>
 #include <xview_private/ultrix_cpt.h>
 
-#if defined(__linux__) && defined(__GLIBC__)
+#if (defined(__linux__) && defined(__GLIBC__)) || defined(__CYGWIN__)
 /* martin.buck@bigfoot.com */
 #if __GLIBC__ == 2 && __GLIBC_MINOR__ == 0
 #include <ioctls.h>
@@ -180,12 +180,14 @@ ttysw_sigwinch(ttysw)
      * SIGWINCHes on resize.
      */
     /* Notify process group that terminal has changed. */
-#ifdef __linux__
+#if defined __linux__ 
     /* Under Linux, we can use this ioctl only on the master pty,
      * otherwise we'll get ENOTTY. It seems to return the right process
      * group nevertheless.
      */
     if (ioctl(ttysw->ttysw_pty, TIOCGPGRP, &pgrp) == -1) {
+#elif defined(__CYGWIN__)
+    if (tcgetpgrp(ttysw->ttysw_pty) == -1 ) {
 #else
     if (ioctl(ttysw->ttysw_tty, TIOCGPGRP, &pgrp) == -1) {
 #endif
@@ -196,7 +198,7 @@ ttysw_sigwinch(ttysw)
      * Only killpg when pgrp is not tool's.  This is the case of haven't
      * completed ttysw_fork yet (or even tried to do it yet).
      */
-#ifndef __linux__
+#if !defined __linux__
     if (getpgrp(0) != pgrp)
 #else
     if (getpgrp() != pgrp)
@@ -225,9 +227,12 @@ ttysw_sendsig(ttysw, textsw, sig)
 	return;
     }
     /* Send the signal to the process group of the controlling tty */
-#ifdef __linux__
+#if defined __linux__
     /* See the comment in ttysw_sigwinch */
     if (ioctl(ttysw->ttysw_pty, TIOCGPGRP, &control_pg) >= 0) {
+#elif defined(__CYGWIN__)
+    control_pg = tcgetpgrp(ttysw->ttysw_pty);
+    if ( control_pg >= 0 ) {
 #else
     if (ioctl(ttysw->ttysw_tty, TIOCGPGRP, &control_pg) >= 0) {
 #endif
@@ -349,7 +354,7 @@ ttysw_reset_conditions(ttysw_view)
     /* Send program output to terminal emulator */
     (void) ttysw_consume_output(ttysw_view);
     /* Toggle between window input and pty output being done */
-    termsw = TERMSW_FOLIO_FOR_VIEW(TERMSW_VIEW_PRIVATE_FROM_TTY_PRIVATE(ttysw));
+    termsw = TERMSW_FOLIO_FOR_VIEW(TERMSW_VIEW_PRIVATE_FROM_TTY_PRIVATE(ttysw));    
     if ((iwbp > irbp && ttysw_pty_output_ok(ttysw)) ||
 	    (ttysw_getopt((caddr_t) ttysw, TTYOPT_TEXT) && termsw != NULL &&
 	    termsw->pty_eot > -1)) {
@@ -376,7 +381,7 @@ ttysw_reset_conditions(ttysw_view)
     if (owbp == orbp) {
 	if (!ttysw_waiting_for_pty_input) {
 	    (void) notify_set_input_func((Notify_client) (TTY_PUBLIC(ttysw)),
-					 ttysw_pty_input_pending, pty);
+	  				 ttysw_pty_input_pending, pty);
 	    ttysw_waiting_for_pty_input = 1;
 	}
     } else {
@@ -394,10 +399,7 @@ ttysw_reset_conditions(ttysw_view)
 	(void) notify_set_itimer_func((Notify_client) (TTY_PUBLIC(ttysw)),
 				      ttysw_itimer_expired,
 				ITIMER_REAL, &ttysw_itimerval, ITIMER_NULL);
-#ifdef DEBUG
-   printf("ttysw_reset_conditions() waiting_for_pty_output=%d, waiting_for_pty_input=%d\n",
-	ttysw_waiting_for_pty_output, ttysw_waiting_for_pty_input);
-#endif
+
 }
 
 
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/tty_stty.c	2013-02-23 14:43:39.953125000 +0000
+++ src/xview-3.2p1.4/lib/libxview/ttysw/tty_stty.c	2013-02-23 14:44:39.312500000 +0000
@@ -122,7 +122,7 @@ we_setptyparms(tp)
      * often have a value of \0.
      */
     strcpy( str, WE_TTYPARMS_E );
-#ifndef __linux__
+#if !defined __linux__ || !defined __CYGWIN__
     (void) sprintf(str + strlen( str ),
 		"%ld,%ld,%ld,%ld,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd",
 		tp->c_iflag, tp->c_oflag, tp->c_cflag, tp->c_lflag,
--- origsrc/xview-3.2p1.4/lib/libxview/ttysw/ttyansi.c	2013-02-23 14:43:39.687500000 +0000
+++ src/xview-3.2p1.4/lib/libxview/ttysw/ttyansi.c	2013-02-23 14:44:39.328125000 +0000
@@ -48,7 +48,7 @@ int             tty_new_cursor_row, tty_
 #define ERROR_RETURN(val)	return(val);
 #endif				/* DEBUG */
 
-#ifndef __linux__
+#if !defined __linux__ && !defined __CYGWIN__
 #define notcontrol(c)	(((c&0177) >= ' ') && (c != '\177'))
 #else
 #define notcontrol(c)	((c >= ' ') && (c != '\177'))
--- origsrc/xview-3.2p1.4/lib/libxview/win/win_input.c	2013-02-23 14:43:41.343750000 +0000
+++ src/xview-3.2p1.4/lib/libxview/win/win_input.c	2013-02-23 14:44:39.390625000 +0000
@@ -82,7 +82,7 @@ Xv_private int  win_handle_window_accel(
 Xv_private int  win_handle_menu_accel();
 /* ACC_XVIEW */
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__CYGWIN__)
 FILE           *fopen(), *fexp;
 #endif
 
--- origsrc/xview-3.2p1.4/lib/libxview/window/windowcmpt.c	1993-06-29 06:15:47.000000000 +0100
+++ src/xview-3.2p1.4/lib/libxview/window/windowcmpt.c	2013-02-23 14:44:39.390625000 +0000
@@ -87,10 +87,13 @@ window_scan_and_convert_to_pixels(win_pu
     Xv_Window       win_public;
     Attr_avlist     avlist;
 {
-    register Window_info *win = WIN_PRIVATE(win_public);
+    register Window_info *win;
     register Attr_avlist attrs;
 
-    for (attrs = avlist; *attrs; attrs = attr_next(attrs)) {
+    if ( win_public ) {
+      win = WIN_PRIVATE(win_public);
+
+      for (attrs = avlist; *attrs; attrs = attr_next(attrs)) {
 	switch ((Window_attribute) attrs[0]) {
 	  case WIN_FONT:
 	    if (attrs[1]) {
@@ -141,8 +144,9 @@ window_scan_and_convert_to_pixels(win_pu
 	    ATTR_CONSUME(attrs[0]);
 	    break;
 	}
+      }
+      window_rc_units_to_pixels(win_public, avlist);
     }
-    window_rc_units_to_pixels(win_public, avlist);
 }
 
 int				/* bool */
--- origsrc/xview-3.2p1.4/lib/libxview/wmgr/wmgr_menu.c	2013-02-23 14:43:38.343750000 +0000
+++ src/xview-3.2p1.4/lib/libxview/wmgr/wmgr_menu.c	2013-02-23 14:44:39.390625000 +0000
@@ -14,8 +14,8 @@ static char     sccsid[] = "@(#)wmgr_men
 #include <stdio.h>
 #include <ctype.h>
 #include <string.h>
-#if defined(sparc) || defined(__linux__)
-#if defined(SVR4) || defined(__linux__)
+#if defined(sparc) || defined(__linux__) || defined(__CYGWIN__)
+#if defined(SVR4) || defined(__linux__) || defined(__CYGWIN__)
 #include <unistd.h>
 #else
 #include <vfork.h>
--- origsrc/xview-3.2p1.4/util/xgettext/xgettext.h	2013-02-23 14:43:36.187500000 +0000
+++ src/xview-3.2p1.4/util/xgettext/xgettext.h	2013-02-23 14:44:39.406250000 +0000
@@ -8,10 +8,10 @@
 #include <signal.h>
 #include <sys/types.h>
 
-#ifndef SVR4
-#include <sys/dir.h>
-#else
+#if defined SVR4 || defined __CYGWIN__
 #include <dirent.h>
+#else
+#include <sys/dir.h>
 #endif /* SVR4 */
 
 #include <sys/param.h>
